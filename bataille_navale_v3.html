<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Bataille navale LAN ‚Äî 26x26</title>
<style>
* { box-sizing: border-box; }
body { 
  font-family: 'Segoe UI', Tahoma, sans-serif; 
  background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 100%);
  color: #e0e8f0;
  min-height: 100vh;
  margin: 0;
  padding: 20px;
}
h2 { 
  text-align: center; 
  color: #4a9eff;
  text-shadow: 0 0 20px rgba(74,158,255,0.5);
  margin-bottom: 10px;
}
.container { max-width: 1300px; margin: 0 auto; }

/* Connexion */
#connect-box {
  background: rgba(255,255,255,0.05);
  border: 1px solid #334;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  transition: all 0.5s;
}
#connect-box.hidden {
  display: none;
}
#connect-box h3 { margin: 0 0 10px 0; color: #6ab7ff; font-size: 14px; }
textarea { 
  width: 100%; 
  height: 70px; 
  background: #0a1020;
  border: 1px solid #445;
  border-radius: 5px;
  color: #8f8;
  font-family: monospace;
  font-size: 11px;
  padding: 8px;
  resize: none;
}
button { 
  margin: 5px 5px 5px 0; 
  padding: 8px 16px; 
  background: linear-gradient(180deg, #2a5a9a, #1a3a6a);
  border: 1px solid #4a7aba;
  border-radius: 5px;
  color: #fff;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s;
}
button:hover { 
  background: linear-gradient(180deg, #3a7aca, #2a5a9a);
  box-shadow: 0 0 15px rgba(74,158,255,0.4);
}
button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Status */
#status {
  text-align: center;
  font-size: 18px;
  padding: 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  margin-bottom: 15px;
  border: 1px solid #334;
}

/* Grilles */
#game-area { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
.grid-container {
  background: rgba(0,20,40,0.6);
  border: 2px solid #2a4a6a;
  border-radius: 10px;
  padding: 15px;
}
.grid-container h4 { 
  margin: 0 0 10px 0; 
  text-align: center;
  color: #8ac;
  font-size: 14px;
}
canvas { 
  border: 2px solid #3a5a7a;
  border-radius: 5px;
  background: linear-gradient(180deg, #051525 0%, #0a2035 100%);
  cursor: crosshair;
}
canvas.blink { 
  animation: blink 0.5s infinite;
  box-shadow: 0 0 25px rgba(255,200,0,0.6);
}
@keyframes blink { 
  0%, 100% { border-color: #3a5a7a; }
  50% { border-color: #fc0; } 
}

/* Panel lat√©ral */
#side-panel {
  background: rgba(0,20,40,0.6);
  border: 2px solid #2a4a6a;
  border-radius: 10px;
  padding: 15px;
  min-width: 180px;
  max-width: 200px;
}
#side-panel h4 { 
  margin: 0 0 10px 0; 
  color: #8ac; 
  text-align: center;
  border-bottom: 1px solid #3a5a7a;
  padding-bottom: 8px;
  font-size: 13px;
}
.ship-status {
  display: flex;
  align-items: center;
  margin: 6px 0;
  padding: 5px 6px;
  background: rgba(0,50,100,0.3);
  border-radius: 5px;
  font-size: 11px;
}
.ship-status.sunk {
  background: rgba(150,0,0,0.3);
  text-decoration: line-through;
  opacity: 0.5;
}
.ship-icon {
  display: flex;
  margin-right: 8px;
}
.ship-cell {
  width: 10px;
  height: 10px;
  background: #4a9;
  margin: 1px;
  border-radius: 2px;
}
.ship-status.sunk .ship-cell { background: #944; }
.ship-name { flex: 1; }
.ship-ability { font-size: 10px; color: #fc0; }

/* Tirs sp√©ciaux */
#fire-mode {
  margin: 10px 0;
  padding: 10px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
}
#fire-mode h4 { margin: 0 0 8px 0; font-size: 12px; color: #8ac; }
.fire-btn {
  display: block;
  width: 100%;
  margin: 4px 0;
  padding: 6px;
  font-size: 11px;
  text-align: left;
}
.fire-btn.active {
  background: linear-gradient(180deg, #5a8a3a, #3a6a2a);
  border-color: #7aba4a;
  box-shadow: 0 0 10px rgba(100,200,50,0.4);
}
.fire-btn:disabled {
  opacity: 0.3;
}

/* Chat */
#chat-box {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
}
#chat-box h4 { margin: 0 0 8px 0; font-size: 12px; color: #8ac; }
#chat-messages {
  height: 80px;
  overflow-y: auto;
  background: #0a1020;
  border-radius: 4px;
  padding: 5px;
  font-size: 11px;
  margin-bottom: 5px;
}
.chat-msg { margin: 2px 0; }
.chat-msg.me { color: #4f8; }
.chat-msg.them { color: #f84; }
#chat-input {
  width: calc(100% - 50px);
  padding: 5px;
  background: #0a1020;
  border: 1px solid #445;
  border-radius: 4px;
  color: #fff;
  font-size: 11px;
}
#chat-send {
  width: 45px;
  padding: 5px;
  font-size: 10px;
}

/* Radar overlay */
.radar-info {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,50,100,0.95);
  border: 2px solid #4af;
  border-radius: 10px;
  padding: 20px 30px;
  font-size: 18px;
  z-index: 100;
  text-align: center;
  box-shadow: 0 0 30px rgba(50,150,255,0.5);
  animation: radarPulse 0.5s;
}
@keyframes radarPulse {
  0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
  100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}

/* L√©gende */
.legend {
  display: flex;
  gap: 15px;
  justify-content: center;
  margin-top: 15px;
  font-size: 11px;
  flex-wrap: wrap;
}
.legend-item { display: flex; align-items: center; gap: 5px; }
.legend-box { width: 14px; height: 14px; border-radius: 3px; }
</style>
</head>
<body>

<div class="container">
  <h2>‚öì Bataille Navale LAN ‚öì</h2>

  <div id="connect-box">
    <h3>üîó Connexion WebRTC (LAN direct)</h3>
    <button onclick="createOffer()">Cr√©er partie</button>
    <button onclick="applyRemote()">Appliquer code re√ßu</button>
    <p style="margin:8px 0 4px;font-size:12px;color:#888;">Code local :</p>
    <textarea id="local" readonly onclick="this.select()"></textarea>
    <p style="margin:8px 0 4px;font-size:12px;color:#888;">Code re√ßu :</p>
    <textarea id="remote" placeholder="Colle ici le code de l'autre joueur..."></textarea>
  </div>

  <div id="status">‚è≥ En attente de connexion‚Ä¶</div>

  <div id="game-area">
    <div class="grid-container">
      <h4>üõ°Ô∏è Ma flotte</h4>
      <canvas id="myGrid" width="520" height="520"></canvas>
    </div>
    <div class="grid-container">
      <h4>üéØ Grille ennemie</h4>
      <canvas id="enemyGrid" width="520" height="520"></canvas>
    </div>
    <div id="side-panel">
      <h4>üéØ Flotte ennemie</h4>
      <div id="enemy-ships"></div>
      
      <div id="fire-mode">
        <h4>üí• Mode de tir</h4>
        <button class="fire-btn active" data-mode="normal" onclick="setFireMode('normal')">üîπ Tir normal</button>
        <button class="fire-btn" data-mode="torpedo" onclick="setFireMode('torpedo')">üêü Torpille (ligne)</button>
        <button class="fire-btn" data-mode="bomb" onclick="setFireMode('bomb')">üí£ Bombe (croix)</button>
        <button class="fire-btn" data-mode="radar" onclick="setFireMode('radar')">üì° Radar (3√ó3)</button>
      </div>
      
      <div id="chat-box">
        <h4>üí¨ Chat (8 car.)</h4>
        <div id="chat-messages"></div>
        <input type="text" id="chat-input" maxlength="8" placeholder="Message...">
        <button id="chat-send" onclick="sendChat()">OK</button>
      </div>
      
      <h4 style="margin-top:15px;">üõ°Ô∏è Ma flotte</h4>
      <div id="my-ships"></div>
    </div>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-box" style="background:#4a9;"></div> Navire</div>
    <div class="legend-item"><div class="legend-box" style="background:#fc0;"></div> Touch√©</div>
    <div class="legend-item"><div class="legend-box" style="background:#e22;"></div> Coul√©</div>
    <div class="legend-item"><div class="legend-box" style="background:#456;"></div> Rat√©</div>
    <div class="legend-item"><div class="legend-box" style="background:#26a;"></div> Radar</div>
  </div>
</div>

<script>
/* ===================== CONSTANTES ===================== */
const SIZE = 26;
const CELL = 20;
const SHIPS = [
  { name:"Porte-avions", size:5, ability:"bomb" },
  { name:"Cuirass√©", size:4, ability:null },
  { name:"Croiseur", size:3, ability:null },
  { name:"Sous-marin", size:3, ability:"torpedo" },
  { name:"Destroyer", size:2, ability:"radar" }
];

const EMPTY = 0, SHIP = 1, HIT = 2, MISS = 3, SUNK = 4, ADJ = 5, RADAR = 6;

/* ===================== √âTAT ===================== */
let myGrid = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
let enemyView = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
let ships = [];
let enemySunk = [];
let myTurn = false;
let gameStarted = false;
let fireMode = "normal";

/* ===================== CANVAS ===================== */
const myC = document.getElementById("myGrid");
const enC = document.getElementById("enemyGrid");
const myCtx = myC.getContext("2d");
const enCtx = enC.getContext("2d");

/* ===================== AUDIO ===================== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playTone(freq, duration, type='sine', vol=0.3) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playSound(result) {
  if (result === "miss") {
    playTone(120, 0.3, 'sine', 0.2);
  } else if (result === "hit") {
    playTone(600, 0.1, 'square', 0.2);
    setTimeout(() => playTone(800, 0.1, 'square', 0.15), 100);
  } else if (result === "sunk") {
    playTone(400, 0.15, 'sawtooth', 0.25);
    setTimeout(() => playTone(300, 0.15, 'sawtooth', 0.2), 150);
    setTimeout(() => playTone(200, 0.4, 'sawtooth', 0.3), 300);
  } else if (result === "radar") {
    playTone(1000, 0.1, 'sine', 0.15);
    setTimeout(() => playTone(1200, 0.1, 'sine', 0.1), 150);
    setTimeout(() => playTone(1400, 0.1, 'sine', 0.08), 300);
  }
}

/* ===================== DESSIN ===================== */
function draw(ctx, grid, reveal=false) {
  ctx.clearRect(0, 0, 520, 520);
  
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const px = x * CELL, py = y * CELL;
      const v = grid[y][x];
      
      let bg = '#0a1a2a';
      if (v === SHIP && reveal) bg = '#2a7a5a';
      else if (v === HIT) bg = '#cc9900';
      else if (v === SUNK) bg = '#cc2222';
      else if (v === MISS || v === ADJ) bg = '#3a4a5a';
      else if (v === RADAR) bg = '#2255aa';
      
      ctx.fillStyle = bg;
      ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
      
      if (v === SHIP && reveal) {
        ctx.fillStyle = '#3a9a7a';
        ctx.fillRect(px + 2, py + 2, CELL - 6, 2);
      } else if (v === HIT) {
        ctx.fillStyle = '#ffcc00';
        ctx.fillRect(px + 2, py + 2, CELL - 6, 2);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px + 5, py + 5);
        ctx.lineTo(px + CELL - 5, py + CELL - 5);
        ctx.moveTo(px + CELL - 5, py + 5);
        ctx.lineTo(px + 5, py + CELL - 5);
        ctx.stroke();
      } else if (v === SUNK) {
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(px + 2, py + 2, CELL - 6, 2);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(px + 4, py + 4);
        ctx.lineTo(px + CELL - 4, py + CELL - 4);
        ctx.moveTo(px + CELL - 4, py + 4);
        ctx.lineTo(px + 4, py + CELL - 4);
        ctx.stroke();
      } else if (v === MISS) {
        ctx.fillStyle = '#6a7a8a';
        ctx.beginPath();
        ctx.arc(px + CELL/2, py + CELL/2, 3, 0, Math.PI * 2);
        ctx.fill();
      } else if (v === RADAR) {
        ctx.fillStyle = '#4488cc';
        ctx.beginPath();
        ctx.arc(px + CELL/2, py + CELL/2, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.strokeStyle = '#2a3a4a';
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, CELL, CELL);
    }
  }
}

/* ===================== PLACEMENT FLOTTE (avec espacement) ===================== */
function canPlace(x, y, size, dir) {
  for (let i = 0; i < size; i++) {
    const nx = x + (dir ? i : 0);
    const ny = y + (dir ? 0 : i);
    if (nx >= SIZE || ny >= SIZE) return false;
    // V√©rifier la case et toutes les adjacentes
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const cx = nx + dx, cy = ny + dy;
        if (cx >= 0 && cx < SIZE && cy >= 0 && cy < SIZE) {
          if (myGrid[cy][cx] !== EMPTY) return false;
        }
      }
    }
  }
  return true;
}

function placeFleet() {
  for (const s of SHIPS) {
    let placed = false;
    let attempts = 0;
    while (!placed && attempts < 1000) {
      const dir = Math.random() < 0.5;
      const x = Math.floor(Math.random() * SIZE);
      const y = Math.floor(Math.random() * SIZE);
      
      if (canPlace(x, y, s.size, dir)) {
        const cells = [];
        for (let i = 0; i < s.size; i++) {
          const nx = x + (dir ? i : 0);
          const ny = y + (dir ? 0 : i);
          myGrid[ny][nx] = SHIP;
          cells.push([nx, ny]);
        }
        ships.push({name: s.name, size: s.size, ability: s.ability, cells, hits: 0});
        placed = true;
      }
      attempts++;
    }
  }
}

function updateShipDisplay() {
  // Ma flotte
  let myHtml = '';
  for (const s of ships) {
    const sunk = s.hits === s.cells.length;
    const abilityText = s.ability ? `<div class="ship-ability">${getAbilityIcon(s.ability)}</div>` : '';
    myHtml += `<div class="ship-status ${sunk ? 'sunk' : ''}">
      <div class="ship-icon">${'<div class="ship-cell"></div>'.repeat(s.size)}</div>
      <span class="ship-name">${s.name}</span>
      ${abilityText}
    </div>`;
  }
  document.getElementById("my-ships").innerHTML = myHtml;
  
  // Flotte ennemie
  let enHtml = '';
  for (const s of SHIPS) {
    const sunk = enemySunk.includes(s.name);
    const abilityText = s.ability ? `<div class="ship-ability">${getAbilityIcon(s.ability)}</div>` : '';
    enHtml += `<div class="ship-status ${sunk ? 'sunk' : ''}">
      <div class="ship-icon">${'<div class="ship-cell"></div>'.repeat(s.size)}</div>
      <span class="ship-name">${s.name}</span>
      ${abilityText}
    </div>`;
  }
  document.getElementById("enemy-ships").innerHTML = enHtml;
  
  // Mettre √† jour les boutons de tir
  updateFireButtons();
}

function getAbilityIcon(ability) {
  if (ability === "torpedo") return "üêü";
  if (ability === "bomb") return "üí£";
  if (ability === "radar") return "üì°";
  return "";
}

function updateFireButtons() {
  const subAlive = ships.some(s => s.ability === "torpedo" && s.hits < s.cells.length);
  const carrierAlive = ships.some(s => s.ability === "bomb" && s.hits < s.cells.length);
  const destroyerAlive = ships.some(s => s.ability === "radar" && s.hits < s.cells.length);
  
  document.querySelector('[data-mode="torpedo"]').disabled = !subAlive;
  document.querySelector('[data-mode="bomb"]').disabled = !carrierAlive;
  document.querySelector('[data-mode="radar"]').disabled = !destroyerAlive;
  
  // Si le mode actuel n'est plus dispo, revenir √† normal
  if ((fireMode === "torpedo" && !subAlive) ||
      (fireMode === "bomb" && !carrierAlive) ||
      (fireMode === "radar" && !destroyerAlive)) {
    setFireMode("normal");
  }
}

placeFleet();
draw(myCtx, myGrid, true);
draw(enCtx, enemyView, false);
updateShipDisplay();

/* ===================== MODE DE TIR ===================== */
function setFireMode(mode) {
  fireMode = mode;
  document.querySelectorAll('.fire-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
}

/* ===================== CASES ADJACENTES ===================== */
function markAdjacentCells(grid, cells) {
  for (const [cx, cy] of cells) {
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = cx + dx, ny = cy + dy;
        if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
          if (grid[ny][nx] === EMPTY) {
            grid[ny][nx] = ADJ;
          }
        }
      }
    }
  }
}

function markShipSunk(grid, cells) {
  for (const [cx, cy] of cells) {
    grid[cy][cx] = SUNK;
  }
  markAdjacentCells(grid, cells);
}

/* ===================== WEBRTC ===================== */
let pc = new RTCPeerConnection();
let dc = null;

pc.onicecandidate = e => {
  if (!e.candidate) {
    document.getElementById("local").value = JSON.stringify(pc.localDescription);
  }
};

pc.ondatachannel = e => {
  dc = e.channel;
  setupDC();
};

function setupDC() {
  dc.onopen = () => {
    gameStarted = true;
    document.getElementById("connect-box").classList.add("hidden");
    myTurn = (pc.localDescription.type === "offer");
    updateStatus();
  };
  dc.onmessage = e => handleMsg(JSON.parse(e.data));
  dc.onclose = () => {
    gameStarted = false;
    document.getElementById("status").textContent = "‚ùå Connexion ferm√©e";
  };
}

function createOffer() {
  dc = pc.createDataChannel("game");
  setupDC();
  pc.createOffer().then(o => pc.setLocalDescription(o));
  document.getElementById("status").textContent = "üìã Offre cr√©√©e, copie le code local...";
}

function applyRemote() {
  try {
    const data = JSON.parse(document.getElementById("remote").value);
    pc.setRemoteDescription(data).then(() => {
      if (data.type === "offer") {
        pc.createAnswer().then(a => pc.setLocalDescription(a));
        document.getElementById("status").textContent = "üìã R√©ponse cr√©√©e, copie le code local...";
      } else {
        document.getElementById("status").textContent = "üîÑ Connexion en cours...";
      }
    });
  } catch(e) {
    alert("Code invalide : " + e.message);
  }
}

/* ===================== CHAT ===================== */
function sendChat() {
  const input = document.getElementById("chat-input");
  const msg = input.value.trim().substring(0, 8);
  if (msg && dc && dc.readyState === "open") {
    dc.send(JSON.stringify({type: "chat", msg}));
    addChatMsg(msg, true);
    input.value = "";
  }
}

document.getElementById("chat-input").addEventListener("keypress", e => {
  if (e.key === "Enter") sendChat();
});

function addChatMsg(msg, isMe) {
  const div = document.getElementById("chat-messages");
  const el = document.createElement("div");
  el.className = "chat-msg " + (isMe ? "me" : "them");
  el.textContent = (isMe ? "‚Üí " : "‚Üê ") + msg;
  div.appendChild(el);
  div.scrollTop = div.scrollHeight;
}

/* ===================== JEU ===================== */
enC.addEventListener("click", e => {
  if (!gameStarted || !myTurn || !dc || dc.readyState !== "open") return;
  
  const x = Math.floor(e.offsetX / CELL);
  const y = Math.floor(e.offsetY / CELL);
  
  if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;
  
  // V√©rifier si d√©j√† jou√© (sauf radar qui peut scanner des zones touch√©es)
  if (fireMode !== "radar" && enemyView[y][x] !== EMPTY && enemyView[y][x] !== RADAR) return;
  
  dc.send(JSON.stringify({type: "shot", x, y, mode: fireMode}));
  myTurn = false;
  updateStatus();
});

function handleMsg(m) {
  if (m.type === "chat") {
    addChatMsg(m.msg, false);
    return;
  }
  
  if (m.type === "shot") {
    const results = [];
    const cells = getShotCells(m.x, m.y, m.mode);
    
    for (const [cx, cy] of cells) {
      if (cx < 0 || cx >= SIZE || cy < 0 || cy >= SIZE) continue;
      
      let hit = false, sunkShip = null;
      
      if (m.mode === "radar") {
        // Radar ne fait pas de d√©g√¢ts
        continue;
      }
      
      for (const s of ships) {
        for (const c of s.cells) {
          if (c[0] === cx && c[1] === cy && myGrid[cy][cx] === SHIP) {
            hit = true;
            s.hits++;
            myGrid[cy][cx] = HIT;
            if (s.hits === s.cells.length) {
              sunkShip = s;
              markShipSunk(myGrid, s.cells);
            }
          }
        }
      }
      
      if (!hit && myGrid[cy][cx] === EMPTY) {
        myGrid[cy][cx] = MISS;
      }
      
      results.push({
        x: cx, y: cy,
        result: hit ? (sunkShip ? "sunk" : "hit") : "miss",
        ship: sunkShip ? sunkShip.name : null,
        cells: sunkShip ? sunkShip.cells : null
      });
    }
    
    // Pour le radar, calculer distance au destroyer
    let radarDist = null;
    if (m.mode === "radar") {
      const myDestroyer = ships.find(s => s.ability === "radar");
      if (myDestroyer) {
        // Centre du destroyer
        const dcx = myDestroyer.cells.reduce((a, c) => a + c[0], 0) / myDestroyer.cells.length;
        const dcy = myDestroyer.cells.reduce((a, c) => a + c[1], 0) / myDestroyer.cells.length;
        radarDist = Math.round(Math.sqrt((m.x - dcx) ** 2 + (m.y - dcy) ** 2));
      }
    }
    
    draw(myCtx, myGrid, true);
    updateShipDisplay();
    
    const hasHit = results.some(r => r.result === "hit" || r.result === "sunk");
    
    dc.send(JSON.stringify({
      type: "result",
      mode: m.mode,
      results,
      radarDist,
      radarCenter: {x: m.x, y: m.y}
    }));
    
    // Jouer le son le plus important
    if (results.some(r => r.result === "sunk")) playSound("sunk");
    else if (hasHit) playSound("hit");
    else if (m.mode === "radar") playSound("radar");
    else playSound("miss");
    
    // Tour suivant
    if (!hasHit || m.mode === "radar") myTurn = true;
    updateStatus();
    checkGameOver();
  }
  
  if (m.type === "result") {
    if (m.mode === "radar") {
      // Marquer la zone radar
      const cells = getShotCells(m.radarCenter.x, m.radarCenter.y, "radar");
      for (const [cx, cy] of cells) {
        if (cx >= 0 && cx < SIZE && cy >= 0 && cy < SIZE && enemyView[cy][cx] === EMPTY) {
          enemyView[cy][cx] = RADAR;
        }
      }
      playSound("radar");
      showRadarInfo(m.radarDist);
    } else {
      for (const r of m.results) {
        if (r.result === "miss") {
          enemyView[r.y][r.x] = MISS;
        } else if (r.result === "hit") {
          enemyView[r.y][r.x] = HIT;
        } else if (r.result === "sunk") {
          enemySunk.push(r.ship);
          if (r.cells) {
            markShipSunk(enemyView, r.cells);
          }
        }
      }
      
      if (m.results.some(r => r.result === "sunk")) playSound("sunk");
      else if (m.results.some(r => r.result === "hit")) playSound("hit");
      else playSound("miss");
    }
    
    draw(enCtx, enemyView, false);
    updateShipDisplay();
    
    const hasHit = m.results && m.results.some(r => r.result === "hit" || r.result === "sunk");
    if (hasHit) myTurn = true;
    updateStatus();
    checkGameOver();
  }
}

function getShotCells(x, y, mode) {
  if (mode === "normal") {
    return [[x, y]];
  } else if (mode === "torpedo") {
    // Ligne horizontale compl√®te
    const cells = [];
    for (let i = 0; i < SIZE; i++) cells.push([i, y]);
    return cells;
  } else if (mode === "bomb") {
    // Croix +
    return [
      [x, y],
      [x-1, y], [x+1, y],
      [x, y-1], [x, y+1]
    ];
  } else if (mode === "radar") {
    // 3x3
    const cells = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        cells.push([x + dx, y + dy]);
      }
    }
    return cells;
  }
  return [[x, y]];
}

function showRadarInfo(dist) {
  const div = document.createElement("div");
  div.className = "radar-info";
  div.innerHTML = `üì° RADAR<br>Destroyer ennemi √†<br><b style="font-size:28px;color:#4f8;">${dist}</b> cases`;
  document.body.appendChild(div);
  setTimeout(() => div.remove(), 2500);
}

/* ===================== STATUS ===================== */
function updateStatus() {
  if (!gameStarted) {
    enC.classList.remove("blink");
    return;
  }
  if (myTurn) {
    enC.classList.add("blink");
    const modeText = {
      normal: "Tir normal",
      torpedo: "üêü TORPILLE (ligne)",
      bomb: "üí£ BOMBE (croix)",
      radar: "üì° RADAR (3√ó3)"
    };
    document.getElementById("status").innerHTML = `üéØ <b>√Ä toi !</b> Mode: ${modeText[fireMode]}`;
  } else {
    enC.classList.remove("blink");
    document.getElementById("status").innerHTML = "‚è≥ Attends ton tour...";
  }
}

/* ===================== FIN DE PARTIE ===================== */
function checkGameOver() {
  if (ships.every(s => s.hits === s.cells.length)) {
    document.getElementById("status").innerHTML = "üíÄ <b>D√âFAITE !</b> Ta flotte est coul√©e.";
    gameStarted = false;
    enC.classList.remove("blink");
  }
  
  if (enemySunk.length === SHIPS.length) {
    document.getElementById("status").innerHTML = "üèÜ <b>VICTOIRE !</b> Flotte ennemie d√©truite !";
    gameStarted = false;
    enC.classList.remove("blink");
  }
}
</script>

</body>
</html>
