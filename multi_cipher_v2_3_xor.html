<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>üîê Multi-Cipher Cracker v2.3</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            color: #ccc;
            min-height: 100vh;
        }
        .container { max-width: 1100px; margin: 0 auto; }
        h1 { text-align: center; color: #00ff88; text-shadow: 0 0 20px #00ff8855; font-size: 32px; margin-bottom: 5px; }
        .version { text-align: center; color: #00ffff; font-size: 12px; margin-bottom: 5px; }
        .subtitle { text-align: center; color: #666; margin-bottom: 25px; font-size: 12px; }
        .new-badge { background: linear-gradient(45deg, #ff6b6b, #ffd93d); color: #000; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: bold; margin-left: 5px; }
        
        label { display: block; margin-top: 15px; font-weight: bold; color: #00ff88; }
        textarea, input[type="text"] { width: 100%; padding: 12px; font-family: 'Courier New', monospace; font-size: 14px; border: 2px solid #00ff88; background: #0a0a1a; color: #fff; border-radius: 8px; resize: vertical; }
        textarea { height: 100px; }
        textarea:focus, input:focus { outline: none; border-color: #00ffff; box-shadow: 0 0 15px #00ffff44; }
        
        .alert { padding: 15px; border-radius: 8px; margin: 15px 0; display: none; }
        .alert-success { background: #0a3a0a; border: 2px solid #00ff88; color: #00ff88; }
        .alert-warning { background: #3a3a0a; border: 2px solid #ffd700; color: #ffd700; }
        .alert.show { display: block; }
        
        .section { background: #111122; border: 1px solid #333; border-radius: 12px; padding: 20px; margin: 20px 0; }
        .section h2 { margin: 0 0 15px 0; color: #00ffff; font-size: 16px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        
        .ic-box { background: linear-gradient(135deg, #1a2a4a 0%, #0a1a3a 100%); border: 2px solid #00ffff; border-radius: 10px; padding: 15px; margin: 15px 0; }
        .ic-value { font-size: 28px; color: #00ffff; font-weight: bold; }
        .ic-label { color: #888; font-size: 12px; }
        .ic-interpretation { margin-top: 10px; padding: 8px; border-radius: 5px; font-size: 12px; }
        .ic-interpretation.french { background: #003366; color: #66ccff; }
        .ic-interpretation.english { background: #660033; color: #ff6699; }
        .ic-interpretation.random { background: #333; color: #999; }
        .ic-interpretation.cleartext { background: #003300; color: #00ff88; }
        
        .keylength-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px; margin-top: 10px; }
        .keylength-item { background: #0a1a2a; border: 1px solid #333; border-radius: 5px; padding: 8px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .keylength-item:hover { border-color: #00ff88; transform: scale(1.05); }
        .keylength-item.selected { border-color: #ffd700; background: #2a2a0a; }
        .keylength-item.disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }
        .keylength-item .len { font-size: 18px; color: #00ffff; font-weight: bold; }
        .keylength-item .pct { font-size: 10px; color: #888; }
        .keylength-item .bar { height: 4px; background: #00ff88; border-radius: 2px; margin-top: 5px; }
        
        .cipher-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin: 15px 0; }
        .cipher-btn { padding: 12px 8px; font-family: 'Courier New', monospace; font-size: 11px; cursor: pointer; border: 2px solid #333; background: #111; color: #888; border-radius: 8px; transition: all 0.2s; text-align: center; position: relative; }
        .cipher-btn:hover { border-color: #00ff88; color: #00ff88; }
        .cipher-btn.active { border-color: #00ff88; background: #00ff8822; color: #00ff88; }
        .cipher-btn .icon { font-size: 18px; display: block; margin-bottom: 5px; }
        .cipher-btn .new-tag { position: absolute; top: -5px; right: -5px; background: #ff6b6b; color: #fff; font-size: 8px; padding: 2px 5px; border-radius: 8px; }
        
        .btn-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin: 20px 0; }
        button { padding: 12px 25px; font-family: 'Courier New', monospace; font-size: 14px; cursor: pointer; border: 2px solid #00ff88; background: transparent; color: #00ff88; border-radius: 25px; transition: all 0.3s; }
        button:hover { background: #00ff88; color: #0a0a1a; box-shadow: 0 0 20px #00ff8855; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-mega { font-size: 20px; padding: 20px 40px; background: linear-gradient(45deg, #00ff88, #00ffff); color: #0a0a1a; border: none; font-weight: bold; animation: glow 2s infinite; }
        .btn-mega:disabled { animation: none; }
        @keyframes glow { 0%, 100% { box-shadow: 0 0 10px #00ff88; } 50% { box-shadow: 0 0 30px #00ff88, 0 0 50px #00ffff; } }
        
        .result-box { background: #0a0a15; border-left: 4px solid #00ff88; padding: 15px; margin: 10px 0; border-radius: 0 8px 8px 0; cursor: pointer; transition: all 0.2s; }
        .result-box:hover { background: #151525; transform: translateX(5px); }
        .result-box.winner { border-left-color: #ffd700; background: linear-gradient(90deg, #1a1a00 0%, #0a0a15 100%); }
        .result-box.cleartext { border-left-color: #00ff88; background: linear-gradient(90deg, #0a2a0a 0%, #0a0a15 100%); }
        .result-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 8px; }
        .result-cipher { color: #00ffff; font-weight: bold; }
        .result-key { color: #ff88ff; }
        .result-score { color: #888; font-size: 12px; }
        .result-text { color: #aaa; font-size: 13px; word-break: break-all; }
        .result-words { color: #00ff88; font-size: 11px; margin-top: 5px; }
        .lang-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: bold; margin-left: 8px; }
        .lang-fr { background: #0066cc; color: #fff; }
        .lang-en { background: #cc3333; color: #fff; }
        
        .progress-container { margin: 15px 0; text-align: center; display: none; }
        .progress-bar { width: 100%; height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00ffff); border-radius: 4px; transition: width 0.3s; width: 0%; }
        .progress-text { color: #00ffff; font-size: 12px; }
        
        .manual-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; }
        .manual-grid label { margin: 0 0 5px 0; font-size: 12px; }
        select { width: 100%; padding: 8px; font-family: 'Courier New', monospace; background: #0a0a1a; color: #fff; border: 1px solid #333; border-radius: 5px; }
        
        #results { max-height: 500px; overflow-y: auto; }
        
        .worker-status { display: inline-flex; align-items: center; gap: 5px; font-size: 11px; color: #888; }
        .worker-dot { width: 8px; height: 8px; border-radius: 50%; background: #00ff88; animation: pulse-dot 1s infinite; }
        .worker-dot.working { background: #ffd700; }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .stats-box { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; margin: 15px 0; }
        .stat-item { background: #0a1a2a; padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 18px; color: #00ffff; font-weight: bold; }
        .stat-label { font-size: 10px; color: #666; }
        
        /* XOR Section */
        .xor-section { background: linear-gradient(135deg, #1a1a3a 0%, #0a1a2a 100%); border: 2px solid #ff88ff; margin-top: 10px; }
        .xor-section h2 { color: #ff88ff; }
        .xor-input-row { display: flex; gap: 15px; align-items: flex-end; flex-wrap: wrap; }
        .xor-input-row > div { flex: 1; min-width: 200px; }
        .xor-input-row input { height: 42px; }
        .xor-hint { font-size: 11px; color: #888; margin-top: 5px; }
    </style>
</head>
<body>

<div class="container">
    <h1>üîê Multi-Cipher Cracker</h1>
    <div class="version">v2.3 <span class="new-badge">XOR + Base64</span></div>
    <p class="subtitle">
        <span class="worker-status">
            <span class="worker-dot" id="workerDot"></span>
            <span id="workerStatus">Pr√™t</span>
        </span>
    </p>
    
    <label for="texte">Texte chiffr√© :</label>
    <textarea id="texte" placeholder="Collez votre texte chiffr√© ici..." oninput="onTextChange()"></textarea>
    
    <div class="alert alert-success" id="alertCleartext">
        ‚úÖ <b>Texte d√©j√† lisible!</b> Score: <span id="cleartextScore">0</span>% - Pas besoin de d√©chiffrement.
    </div>
    <div class="alert alert-warning" id="alertNoKeys">
        ‚ö†Ô∏è <b>Analyse incertaine.</b> Aucune longueur de cl√© probable (>1%).
    </div>
    
    <div class="section">
        <h2>üìä Analyse du texte</h2>
        <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 20px;">
            <div class="ic-box">
                <div class="ic-label">Indice de Co√Øncidence</div>
                <div class="ic-value" id="icValue">-</div>
                <div class="ic-interpretation" id="icInterpretation">Entrez du texte...</div>
            </div>
            <div>
                <div style="color: #888; font-size: 12px; margin-bottom: 10px;">Longueurs de cl√© probables (&gt;1%) :</div>
                <div class="keylength-grid" id="keyLengthGrid">
                    <div class="keylength-item disabled"><div class="len">-</div><div class="pct">En attente</div></div>
                </div>
            </div>
        </div>
        <div class="stats-box" id="statsBox" style="display:none;">
            <div class="stat-item"><div class="stat-value" id="statLength">0</div><div class="stat-label">Caract√®res</div></div>
            <div class="stat-item"><div class="stat-value" id="statLetters">0</div><div class="stat-label">Lettres</div></div>
            <div class="stat-item"><div class="stat-value" id="statClearScore">0%</div><div class="stat-label">Score brut</div></div>
        </div>
    </div>
    
    <div class="section">
        <h2>üéØ Chiffrements</h2>
        <div class="cipher-grid">
            <div class="cipher-btn active" data-cipher="caesar" onclick="toggleCipher(this)"><span class="icon">üîÑ</span>C√©sar</div>
            <div class="cipher-btn active" data-cipher="vigenere" onclick="toggleCipher(this)"><span class="icon">üîë</span>Vigen√®re</div>
            <div class="cipher-btn active" data-cipher="atbash" onclick="toggleCipher(this)"><span class="icon">üîÄ</span>Atbash</div>
            <div class="cipher-btn active" data-cipher="affine" onclick="toggleCipher(this)"><span class="icon">‚úñÔ∏è</span>Affine</div>
            <div class="cipher-btn active" data-cipher="beaufort" onclick="toggleCipher(this)"><span class="icon">‚öì</span>Beaufort</div>
            <div class="cipher-btn active" data-cipher="autokey" onclick="toggleCipher(this)"><span class="icon">üîó</span>Autokey<span class="new-tag">v2</span></div>
            <div class="cipher-btn active" data-cipher="playfair" onclick="toggleCipher(this)"><span class="icon">üé≤</span>Playfair<span class="new-tag">v2</span></div>
            <div class="cipher-btn" data-cipher="railfence" onclick="toggleCipher(this)"><span class="icon">üöÉ</span>Rail Fence</div>
            <div class="cipher-btn" data-cipher="columnar" onclick="toggleCipher(this)"><span class="icon">üìä</span>Colonnes</div>
            <div class="cipher-btn" data-cipher="reverse" onclick="toggleCipher(this)"><span class="icon">‚Ü©Ô∏è</span>Reverse</div>
            <div class="cipher-btn active" data-cipher="cascade" onclick="toggleCipher(this)"><span class="icon">‚õìÔ∏è</span>CASCADE</div>
            <div class="cipher-btn" data-cipher="xorbase64" onclick="toggleCipher(this)"><span class="icon">‚äï</span>XOR+B64<span class="new-tag">NEW</span></div>
        </div>
    </div>
    
    <!-- XOR Section -->
    <div class="section xor-section" id="xorSection" style="display:none;">
        <h2>‚äï Options XOR / Base64</h2>
        <div class="xor-input-row">
            <div>
                <label style="margin-top:0;">Cl√© XOR (optionnel)</label>
                <input type="text" id="xorKey" placeholder="Laisser vide pour attaque auto">
                <div class="xor-hint">Si connue, saisir la cl√© pour d√©chiffrement direct</div>
            </div>
            <div>
                <label style="margin-top:0;">Longueur cl√© (auto)</label>
                <select id="xorKeyLength">
                    <option value="auto" selected>Auto-d√©tection</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                    <option value="13">13</option>
                    <option value="14">14</option>
                    <option value="15">15</option>
                    <option value="16">16</option>
                </select>
                <div class="xor-hint">Utilis√© uniquement si cl√© non fournie</div>
            </div>
        </div>
    </div>
    
    <div class="btn-row">
        <button class="btn-mega" id="crackBtn" onclick="crackAll()">üöÄ CRACK!</button>
    </div>
    
    <div class="section">
        <h2>‚öôÔ∏è Options</h2>
        <div class="manual-grid">
            <div>
                <label>Longueur cl√© (Vigen√®re)</label>
                <select id="keyLengthSelect">
                    <option value="auto" selected>Auto</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                </select>
            </div>
            <div>
                <label>Langue</label>
                <select id="targetLang">
                    <option value="both" selected>FR + EN</option>
                    <option value="fr">Fran√ßais</option>
                    <option value="en">English</option>
                </select>
            </div>
            <div>
                <label>Max r√©sultats</label>
                <select id="maxResults">
                    <option value="20">20</option>
                    <option value="40" selected>40</option>
                    <option value="80">80</option>
                </select>
            </div>
            <div>
                <label>Score min</label>
                <select id="minScore">
                    <option value="30">30%</option>
                    <option value="40">40%</option>
                    <option value="50" selected>50%</option>
                    <option value="60">60%</option>
                </select>
            </div>
        </div>
    </div>
    
    <div class="btn-row">
        <button onclick="clearResults()">üóëÔ∏è Effacer</button>
    </div>
    
    <div class="progress-container" id="progressContainer">
        <div class="progress-text" id="progressText">...</div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    </div>
    
    <div id="results"></div>
</div>

<script>
// ============================================================
// WORKER CODE (sera converti en Blob)
// ============================================================
const workerCode = `
const FRENCH_WORDS = new Set(['le','la','les','un','une','des','du','de','au','aux','ce','cette','ces','cet','mon','ma','mes','ton','ta','tes','son','sa','ses','notre','nos','votre','vos','leur','leurs','je','tu','il','elle','on','nous','vous','ils','elles','me','te','se','lui','eux','moi','toi','qui','que','quoi','dont','ou','a','en','dans','sur','sous','avec','sans','pour','par','chez','vers','entre','contre','devant','derriere','depuis','pendant','avant','apres','et','mais','donc','or','ni','car','si','comme','quand','lorsque','puisque','parce','ne','pas','plus','moins','tres','bien','mal','peu','beaucoup','trop','assez','aussi','toujours','jamais','souvent','parfois','encore','deja','maintenant','hier','demain','ici','oui','non','peut','etre','vraiment','comment','pourquoi','combien','suis','es','est','sommes','etes','sont','etais','etait','serai','sera','seront','ai','as','avons','avez','ont','avais','avait','aurai','aura','auront','faire','fais','fait','faisons','faites','font','fera','dire','dis','dit','dira','aller','vais','vas','va','allons','allez','vont','ira','voir','vois','voit','verra','savoir','sais','sait','savons','savent','pouvoir','peux','peut','pouvons','peuvent','vouloir','veux','veut','voulons','veulent','venir','viens','vient','venons','viennent','prendre','prends','prend','prenons','prennent','mettre','mets','met','mettons','mettent','falloir','faut','devoir','dois','doit','devons','doivent','croire','crois','croit','homme','femme','enfant','monde','temps','jour','nuit','annee','mois','semaine','heure','moment','fois','vie','mort','chose','cas','part','pays','ville','rue','maison','place','point','coup','main','tete','coeur','corps','oeil','yeux','voix','nom','mot','lettre','livre','histoire','question','reponse','raison','idee','probleme','solution','travail','argent','prix','eau','feu','terre','air','ciel','soleil','lune','mer','montagne','arbre','foret','pere','mere','fils','fille','frere','soeur','ami','amie','famille','groupe','roi','reine','prince','guerre','paix','pouvoir','force','ordre','loi','droit','secret','message','code','cle','porte','chemin','route','fin','debut','milieu','soir','matin','present','passe','bon','bonne','mauvais','grand','grande','petit','petite','beau','belle','nouveau','nouvelle','vieux','vieille','jeune','premier','derniere','seul','seule','autre','meme','tout','tous','toute','toutes','vrai','faux','possible','facile','difficile','long','court','haut','bas','blanc','noir','rouge','bleu','vert','jaune','deux','trois','quatre','cinq','six','sept','huit','neuf','dix','cent','mille']);
const ENGLISH_WORDS = new Set(['brown','dog','jump','above','lazy','dog','cat','the','a','an','this','that','these','those','my','your','his','her','its','our','their','some','any','no','every','each','all','both','few','many','much','most','other','i','you','he','she','it','we','they','him','us','them','who','what','which','on','at','to','for','of','with','by','from','up','down','into','out','over','under','about','above','below','between','through','during','before','after','and','or','but','so','yet','because','although','while','when','where','if','not','very','well','also','just','only','even','still','already','always','never','often','sometimes','really','quite','here','there','now','then','today','yes','be','am','is','are','was','were','been','being','have','has','had','having','do','does','did','doing','done','say','says','said','get','gets','got','make','makes','made','go','goes','went','gone','know','knows','knew','known','take','takes','took','taken','see','sees','saw','seen','come','comes','came','think','thinks','thought','look','looks','looked','want','wants','wanted','give','gives','gave','given','use','uses','used','find','finds','found','tell','tells','told','ask','asks','asked','work','works','worked','time','year','people','way','day','man','woman','child','world','life','hand','part','place','case','week','number','night','point','home','water','room','mother','area','money','story','fact','month','right','book','eye','job','word','business','side','kind','head','house','friend','father','power','hour','game','line','end','member','law','car','city','name','team','good','new','first','last','long','great','little','own','old','big','high','different','small','large','next','young','important','public','bad','same','able','one','two','three','four','five','six','seven','eight','nine','ten','hundred','thousand','key','code','secret','message','king','queen','war','peace','love','death','fire','light','dark','white','black','red']);
const FRENCH_FREQ = {E:14.7,A:7.6,I:7.5,S:7.9,N:7.1,R:6.6,T:7.2,O:5.4,L:5.5,U:6.3,D:3.7,C:3.3,M:3.0,P:3.0};
const ENGLISH_FREQ = {E:12.7,T:9.1,A:8.2,O:7.5,I:7.0,N:6.7,S:6.3,H:6.1,R:6.0,D:4.3,L:4.0,C:2.8,U:2.8,M:2.4};
const COPRIME = [1,3,5,7,9,11,15,17,19,21,23,25];
const MOD_INV = {1:1,3:9,5:21,7:15,9:3,11:19,15:7,17:23,19:11,21:5,23:17,25:25};
const KEYWORDS = ['TRESOR'];

// Fr√©quences des bytes pour texte fran√ßais (espace et lettres minuscules principalement)
const FRENCH_BYTE_FREQ = {
    32: 17.0,  // espace
    101: 14.7, // e
    97: 7.6,   // a
    105: 7.5,  // i
    115: 7.9,  // s
    110: 7.1,  // n
    114: 6.6,  // r
    116: 7.2,  // t
    111: 5.4,  // o
    108: 5.5,  // l
    117: 6.3,  // u
    100: 3.7,  // d
    99: 3.3,   // c
    109: 3.0,  // m
    112: 3.0   // p
};

function caesar(t,s,d=true){const sh=d?(26-s)%26:s;return t.replace(/[a-zA-Z]/g,c=>{const b=c<='Z'?65:97;return String.fromCharCode((c.charCodeAt(0)-b+sh)%26+b);});}
function atbash(t){return t.replace(/[a-zA-Z]/g,c=>{const b=c<='Z'?65:97;return String.fromCharCode(b+25-(c.charCodeAt(0)-b));});}
function affine(t,a,b,d=true){if(d){const ai=MOD_INV[a];return t.replace(/[a-zA-Z]/g,c=>{const bs=c<='Z'?65:97;const y=c.charCodeAt(0)-bs;return String.fromCharCode(((ai*(y-b+26))%26+26)%26+bs);});}return t.replace(/[a-zA-Z]/g,c=>{const bs=c<='Z'?65:97;const x=c.charCodeAt(0)-bs;return String.fromCharCode((a*x+b)%26+bs);});}
function vigenere(t,key,d=true){let r='',ki=0;const k=key.toUpperCase();for(const c of t){if(/[a-zA-Z]/.test(c)){const b=c<='Z'?65:97;const s=k.charCodeAt(ki%k.length)-65;const v=c.charCodeAt(0)-b;const nv=d?(v-s+26)%26:(v+s)%26;r+=String.fromCharCode(nv+b);ki++;}else r+=c;}return r;}
function beaufort(t,key){let r='',ki=0;const k=key.toUpperCase();for(const c of t){if(/[a-zA-Z]/.test(c)){const b=c<='Z'?65:97;const kv=k.charCodeAt(ki%k.length)-65;const tv=c.charCodeAt(0)-b;r+=String.fromCharCode((kv-tv+26)%26+b);ki++;}else r+=c;}return r;}
function autokey(t,p){let r='',ks=p.toUpperCase(),ki=0;for(const c of t){if(/[a-zA-Z]/.test(c)){const b=c<='Z'?65:97;const s=ks.charCodeAt(ki)-65;const v=c.charCodeAt(0)-b;const d=(v-s+26)%26;const dc=String.fromCharCode(d+65);r+=b===65?dc:dc.toLowerCase();ks+=dc;ki++;}else r+=c;}return r;}
function playfair(t,key){const g=[];const seen=new Set();const ku=key.toUpperCase().replace(/J/g,'I').replace(/[^A-Z]/g,'');for(const c of ku)if(!seen.has(c)){seen.add(c);g.push(c);}for(let i=0;i<26;i++){const c=String.fromCharCode(65+i);if(c!=='J'&&!seen.has(c)){seen.add(c);g.push(c);}}const find=(ch)=>{const c=ch==='J'?'I':ch;const idx=g.indexOf(c);return{r:Math.floor(idx/5),c:idx%5};};const cl=t.toUpperCase().replace(/[^A-Z]/g,'').replace(/J/g,'I');let pr='';for(let i=0;i<cl.length;i++){pr+=cl[i];if(i+1<cl.length&&cl[i]===cl[i+1])pr+='X';}if(pr.length%2)pr+='X';let r='';for(let i=0;i<pr.length;i+=2){const p1=find(pr[i]),p2=find(pr[i+1]);let n1,n2;if(p1.r===p2.r){n1=g[p1.r*5+(p1.c+4)%5];n2=g[p2.r*5+(p2.c+4)%5];}else if(p1.c===p2.c){n1=g[((p1.r+4)%5)*5+p1.c];n2=g[((p2.r+4)%5)*5+p2.c];}else{n1=g[p1.r*5+p2.c];n2=g[p2.r*5+p1.c];}r+=n1+n2;}return r;}
function railfence(t,rails){const cl=t.replace(/[^a-zA-Z]/g,'');const n=cl.length;if(rails<2||rails>=n)return t;const rl=new Array(rails).fill(0);let rail=0,dir=1;for(let i=0;i<n;i++){rl[rail]++;rail+=dir;if(rail===0||rail===rails-1)dir=-dir;}const rt=[];let pos=0;for(let r=0;r<rails;r++){rt.push(cl.substring(pos,pos+rl[r]));pos+=rl[r];}const idx=new Array(rails).fill(0);let res='';rail=0;dir=1;for(let i=0;i<n;i++){res+=rt[rail][idx[rail]++];rail+=dir;if(rail===0||rail===rails-1)dir=-dir;}return res;}
function columnar(t,w){const cl=t.replace(/[^a-zA-Z]/g,'');const n=cl.length;const rows=Math.ceil(n/w);const fc=n%w||w;let r='';for(let ro=0;ro<rows;ro++){for(let c=0;c<w;c++){const cLen=c<fc?rows:rows-1;const off=c<fc?c*rows:fc*rows+(c-fc)*(rows-1);if(ro<cLen)r+=cl[off+ro]||'';}}return r;}
function reverse(t){return t.split('').reverse().join('');}

// ============================================================
// XOR + BASE64 FUNCTIONS
// ============================================================
function base64Decode(str) {
    try {
        // Standard base64 decoding
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        let result = [];
        str = str.replace(/[^A-Za-z0-9+/=]/g, '');
        
        for (let i = 0; i < str.length; i += 4) {
            const a = chars.indexOf(str[i]);
            const b = chars.indexOf(str[i + 1]);
            const c = chars.indexOf(str[i + 2]);
            const d = chars.indexOf(str[i + 3]);
            
            result.push((a << 2) | (b >> 4));
            if (str[i + 2] !== '=') result.push(((b & 15) << 4) | (c >> 2));
            if (str[i + 3] !== '=') result.push(((c & 3) << 6) | d);
        }
        return new Uint8Array(result);
    } catch (e) {
        return null;
    }
}

function xorDecrypt(data, key) {
    const keyBytes = typeof key === 'string' 
        ? new Uint8Array([...key].map(c => c.charCodeAt(0)))
        : key;
    const result = new Uint8Array(data.length);
    for (let i = 0; i < data.length; i++) {
        result[i] = data[i] ^ keyBytes[i % keyBytes.length];
    }
    return result;
}

function bytesToString(bytes) {
    let result = '';
    for (let i = 0; i < bytes.length; i++) {
        result += String.fromCharCode(bytes[i]);
    }
    return result;
}

function scoreXorResult(bytes) {
    // Score bas√© sur les caract√®res imprimables fran√ßais
    let score = 0;
    let printable = 0;
    let letters = 0;
    let spaces = 0;
    
    for (let i = 0; i < bytes.length; i++) {
        const b = bytes[i];
        // Caract√®res imprimables ASCII (32-126)
        if (b >= 32 && b <= 126) {
            printable++;
            // Lettres
            if ((b >= 65 && b <= 90) || (b >= 97 && b <= 122)) {
                letters++;
                score += 2;
            }
            // Espace
            else if (b === 32) {
                spaces++;
                score += 3;
            }
            // Ponctuation commune
            else if ([44, 46, 39, 33, 63, 58, 59].includes(b)) {
                score += 1;
            }
        }
        // Caract√®res accentu√©s courants (UTF-8 √©tendu pour fran√ßais)
        else if (b >= 192 && b <= 255) {
            score += 1;
        }
        // Caract√®res non imprimables = p√©nalit√©
        else {
            score -= 5;
        }
    }
    
    const ratio = printable / bytes.length;
    const letterRatio = letters / bytes.length;
    const spaceRatio = spaces / bytes.length;
    
    // Bonus pour ratios typiques de texte fran√ßais
    if (ratio > 0.95) score += 20;
    if (letterRatio > 0.7 && letterRatio < 0.9) score += 15;
    if (spaceRatio > 0.1 && spaceRatio < 0.25) score += 10;
    
    return score;
}

function findBestKeyByte(column) {
    let bestByte = 0;
    let bestScore = -Infinity;
    
    for (let k = 0; k < 256; k++) {
        let score = 0;
        for (let i = 0; i < column.length; i++) {
            const decrypted = column[i] ^ k;
            // Score bas√© sur fr√©quences fran√ßaises
            if (FRENCH_BYTE_FREQ[decrypted]) {
                score += FRENCH_BYTE_FREQ[decrypted];
            }
            // Bonus pour caract√®res imprimables
            if (decrypted >= 32 && decrypted <= 126) {
                score += 1;
            }
            // P√©nalit√© pour non-imprimables
            else if (decrypted < 32 || decrypted > 126) {
                score -= 10;
            }
        }
        if (score > bestScore) {
            bestScore = score;
            bestByte = k;
        }
    }
    return bestByte;
}

function detectXorKeyLength(data, maxLen = 16) {
    // M√©thode de Hamming distance normalis√©e
    const results = [];
    
    for (let keyLen = 1; keyLen <= Math.min(maxLen, Math.floor(data.length / 4)); keyLen++) {
        let totalDist = 0;
        let pairs = 0;
        
        // Comparer plusieurs blocs
        const numBlocks = Math.min(8, Math.floor(data.length / keyLen));
        for (let i = 0; i < numBlocks - 1; i++) {
            for (let j = i + 1; j < numBlocks; j++) {
                let dist = 0;
                for (let k = 0; k < keyLen; k++) {
                    const b1 = data[i * keyLen + k];
                    const b2 = data[j * keyLen + k];
                    // Hamming distance
                    let xor = b1 ^ b2;
                    while (xor) {
                        dist += xor & 1;
                        xor >>= 1;
                    }
                }
                totalDist += dist;
                pairs++;
            }
        }
        
        const normalizedDist = pairs > 0 ? (totalDist / pairs) / keyLen : Infinity;
        results.push({ len: keyLen, dist: normalizedDist });
    }
    
    results.sort((a, b) => a.dist - b.dist);
    return results.slice(0, 5).map(r => r.len);
}

function crackXorWithKeyLength(data, keyLen) {
    const key = new Uint8Array(keyLen);
    
    // Diviser en colonnes
    for (let i = 0; i < keyLen; i++) {
        const column = [];
        for (let j = i; j < data.length; j += keyLen) {
            column.push(data[j]);
        }
        key[i] = findBestKeyByte(column);
    }
    
    return key;
}

function crackXor(text, knownKey, keyLengthHint, lang) {
    const results = [];
    
    // D√©coder Base64
    const data = base64Decode(text.trim());
    if (!data || data.length < 4) {
        return results;
    }
    
    // Si cl√© connue, d√©chiffrement direct
    if (knownKey && knownKey.length > 0) {
        const decrypted = xorDecrypt(data, knownKey);
        const plaintext = bytesToString(decrypted);
        const sc = score(plaintext, lang);
        results.push({
            cipher: 'XOR+Base64',
            key: 'Cl√©: "' + knownKey + '"',
            text: plaintext,
            ...sc
        });
        return results;
    }
    
    // Attaque statistique
    let keyLengths;
    if (keyLengthHint && keyLengthHint !== 'auto') {
        keyLengths = [parseInt(keyLengthHint)];
    } else {
        // Auto-d√©tection
        keyLengths = detectXorKeyLength(data, 16);
    }
    
    for (const keyLen of keyLengths) {
        const key = crackXorWithKeyLength(data, keyLen);
        const decrypted = xorDecrypt(data, key);
        const plaintext = bytesToString(decrypted);
        
        // V√©rifier si r√©sultat est lisible
        const xorScore = scoreXorResult(decrypted);
        if (xorScore > 0) {
            const sc = score(plaintext, lang);
            
            // Reconstruire la cl√© en ASCII si possible
            let keyStr = '';
            let keyHex = '';
            for (let i = 0; i < key.length; i++) {
                if (key[i] >= 32 && key[i] <= 126) {
                    keyStr += String.fromCharCode(key[i]);
                } else {
                    keyStr += '\\\\x' + key[i].toString(16).padStart(2, '0');
                }
                keyHex += key[i].toString(16).padStart(2, '0');
            }
            
            results.push({
                cipher: 'XOR+Base64',
                key: '"' + keyStr + '" (0x' + keyHex + ')',
                text: plaintext,
                ...sc,
                xorScore
            });
        }
    }
    
    // Trier par score
    results.sort((a, b) => b.score - a.score);
    return results.slice(0, 5);
}

const segCache=new Map();
function segment(t,dict){const n=t.toLowerCase().replace(/[^a-z]/g,'');if(!n.length)return{w:[],cov:0};const k=n.slice(0,30)+n.length+(dict===FRENCH_WORDS?'F':'E');if(segCache.has(k))return segCache.get(k);const len=n.length;const dp=new Array(len+1).fill(0);const par=new Array(len+1).fill(-1);for(let i=1;i<=len;i++){dp[i]=dp[i-1];par[i]=i-1;for(let l=2;l<=Math.min(i,10);l++){const w=n.substring(i-l,i);if(dict.has(w)&&dp[i-l]+l*l>dp[i]){dp[i]=dp[i-l]+l*l;par[i]=i-l;}}}const words=[];let p=len,cov=0;while(p>0){const pr=par[p];const l=p-pr;if(l>1){const w=n.substring(pr,p);if(dict.has(w)){words.unshift(w);cov+=l;}}p=pr;}const res={w:words,cov:len>0?(cov/len)*100:0};if(segCache.size>300)segCache.clear();segCache.set(k,res);return res;}

function getFreq(t){const f={};let tot=0;for(const c of t.toUpperCase())if(c>='A'&&c<='Z'){f[c]=(f[c]||0)+1;tot++;}if(!tot)return{};for(const c in f)f[c]=(f[c]/tot)*100;return f;}
function freqScore(t,tgt){const f=getFreq(t);let d=0;for(const l in tgt)d+=Math.abs((tgt[l]||0)-(f[l]||0));return Math.max(0,100-d);}
function score(t,lang='both'){const frF=freqScore(t,FRENCH_FREQ),enF=freqScore(t,ENGLISH_FREQ);let frD=0,enD=0,frW=[],enW=[];if(frF>40||lang==='fr'){const s=segment(t,FRENCH_WORDS);frD=s.cov;frW=s.w;}if(enF>40||lang==='en'){const s=segment(t,ENGLISH_WORDS);enD=s.cov;enW=s.w;}const frS=frD*0.7+frF*0.3,enS=enD*0.7+enF*0.3;if(lang==='fr')return{score:frS,lang:'fr',dict:frD,freq:frF,words:frW};if(lang==='en')return{score:enS,lang:'en',dict:enD,freq:enF,words:enW};return frS>enS?{score:frS,lang:'fr',dict:frD,freq:frF,words:frW}:{score:enS,lang:'en',dict:enD,freq:enF,words:enW};}

function* vigenereKeys(len, text) {
    if (len <= 3) {
        function* gen(curr) {
            if (curr.length === len) { yield curr; return; }
            for (let i = 0; i < 26; i++) yield* gen(curr + String.fromCharCode(65 + i));
        }
        yield* gen("");
        return;
    }

    const cl = text.toUpperCase().replace(/[^A-Z]/g, '');
    const cols = [];
    for (let i = 0; i < len; i++) {
        let c = '';
        for (let j = i; j < cl.length; j += len) c += cl[j];
        cols.push(c);
    }
    
    const best = cols.map(col => {
        const sc = [];
        for (let s = 0; s < 26; s++) {
            let d = '';
            for (const c of col) d += String.fromCharCode(((c.charCodeAt(0) - 65 - s + 26) % 26) + 65);
            sc.push({
                l: String.fromCharCode(65 + s),
                s: Math.max(freqScore(d, FRENCH_FREQ), freqScore(d, ENGLISH_FREQ))
            });
        }
        sc.sort((a, b) => b.s - a.s);
        const n = len <= 4 ? 20 : (len <= 5 ? 12 : 3);
        return sc.slice(0, n).map(x => x.l);
    });

    function* combos(arrs, pre = '') {
        if (!arrs.length) { yield pre; return; }
        for (const l of arrs[0]) yield* combos(arrs.slice(1), pre + l);
    }
    yield* combos(best);
}

self.onmessage=function(e){
const{action,text,options}=e.data;
if(action!=='crack')return;
const{ciphers,lang,maxResults,minScore,keyLengths,xorKey,xorKeyLength}=options;
let all=[];
const total=ciphers.length;
let step=0;

for(const cipher of ciphers){
step++;
self.postMessage({action:'progress',cipher,step,total});

if(cipher==='caesar'){for(let s=1;s<26;s++){const d=caesar(text,s);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'C√©sar',key:'ROT'+s,text:d,...sc});}}
else if(cipher==='atbash'){const d=atbash(text);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Atbash',key:'A‚ÜîZ',text:d,...sc});}
else if(cipher==='reverse'){const d=reverse(text);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Reverse',key:'‚Üê',text:d,...sc});}
else if(cipher==='affine'){for(const a of COPRIME)for(let b=0;b<26;b++){if(a===1&&b===0)continue;const d=affine(text,a,b);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Affine',key:'a='+a+',b='+b,text:d,...sc});}}
else if(cipher==='vigenere'){for(const len of keyLengths){let count=0;for(const key of vigenereKeys(len,text)){const d=vigenere(text,key);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Vigen√®re',key,text:d,...sc});count++;if(count>12000000)break;}}}
else if(cipher==='beaufort'){for(const len of keyLengths){let count=0;for(const key of vigenereKeys(len,text)){const d=beaufort(text,key);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Beaufort',key,text:d,...sc});count++;if(count>12000000)break;}}}
else if(cipher==='autokey'){for(const p of KEYWORDS.slice(0,20)){const d=autokey(text,p);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Autokey',key:p,text:d,...sc});}}
else if(cipher==='playfair'){for(const k of KEYWORDS.slice(0,20)){const d=playfair(text,k);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Playfair',key:k,text:d,...sc});}}
else if(cipher==='railfence'){for(let r=2;r<=10;r++){const d=railfence(text,r);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Rail Fence',key:r+' rails',text:d,...sc});}}
else if(cipher==='columnar'){for(let w=2;w<=10;w++){const d=columnar(text,w);const sc=score(d,lang);if(sc.score>=minScore)all.push({cipher:'Colonnes',key:'w='+w,text:d,...sc});}}
else if(cipher==='xorbase64'){
    const xorResults = crackXor(text, xorKey, xorKeyLength, lang);
    for (const r of xorResults) {
        if (r.score >= minScore || (xorKey && xorKey.length > 0)) {
            all.push(r);
        }
    }
}
else if(cipher==='cascade'){
const top=[...all].sort((a,b)=>b.score-a.score).slice(0,8);
for(const r of top){
const c1=atbash(r.text);const s1=score(c1,lang);if(s1.score>r.score&&s1.score>=minScore)all.push({cipher:r.cipher+' ‚Üí Atbash',key:r.key+' ‚Üí A‚ÜîZ',text:c1,...s1});
const c2=caesar(r.text,13,false);const s2=score(c2,lang);if(s2.score>r.score&&s2.score>=minScore)all.push({cipher:r.cipher+' ‚Üí ROT13',key:r.key+' ‚Üí 13',text:c2,...s2});
const c3=reverse(r.text);const s3=score(c3,lang);if(s3.score>r.score&&s3.score>=minScore)all.push({cipher:r.cipher+' ‚Üí Reverse',key:r.key+' ‚Üí ‚Üê',text:c3,...s3});
}}
}

all.sort((a,b)=>b.score-a.score);
const seen=new Set();
all=all.filter(r=>{const k=r.text.slice(0,80);if(seen.has(k))return false;seen.add(k);return true;});
all=all.slice(0,maxResults);
self.postMessage({action:'results',results:all});
};
`;

// ============================================================
// MAIN SCRIPT
// ============================================================
let worker = null;
let isWorking = false;

function initWorker() {
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    worker = new Worker(URL.createObjectURL(blob));
    worker.onmessage = function(e) {
        const { action, results, cipher, step, total } = e.data;
        if (action === 'progress') {
            const pct = Math.round((step / total) * 100);
            document.getElementById('progressFill').style.width = pct + '%';
            document.getElementById('progressText').textContent = `${cipher} (${step}/${total})`;
        } else if (action === 'results') {
            setWorking(false);
            displayResults(results);
        }
    };
}

function setWorking(w) {
    isWorking = w;
    document.getElementById('crackBtn').disabled = w;
    document.getElementById('workerDot').classList.toggle('working', w);
    document.getElementById('workerStatus').textContent = w ? 'Analyse...' : 'Pr√™t';
    document.getElementById('progressContainer').style.display = w ? 'block' : 'none';
}

// ============================================================
// TEXT ANALYSIS
// ============================================================
function calculateIC(text) {
    const clean = text.toUpperCase().replace(/[^A-Z]/g, '');
    if (clean.length < 2) return 0;
    const freq = {};
    for (const c of clean) freq[c] = (freq[c] || 0) + 1;
    let sum = 0;
    for (const c in freq) sum += freq[c] * (freq[c] - 1);
    return sum / (clean.length * (clean.length - 1));
}

function analyzeKeyLength(text, maxLen = 20) {
    const clean = text.toUpperCase().replace(/[^A-Z]/g, '');
    if (clean.length < 20) return [];
    const results = [];
    for (let len = 2; len <= Math.min(maxLen, clean.length / 3); len++) {
        let icSum = 0;
        for (let i = 0; i < len; i++) {
            let substr = '';
            for (let j = i; j < clean.length; j += len) substr += clean[j];
            icSum += calculateIC(substr);
        }
        results.push({ length: len, ic: icSum / len });
    }
    const target = 0.074;
    results.forEach(r => r.diff = Math.abs(r.ic - target));
    results.sort((a, b) => a.diff - b.diff);
    const minDiff = results[0]?.diff || 1;
    results.forEach(r => r.percentage = minDiff > 0 ? Math.max(0, 100 * (1 - (r.diff - minDiff) / 0.02)) : 100);
    return results.sort((a, b) => b.percentage - a.percentage).slice(0, 10);
}

function quickScore(text) {
    const clean = text.toLowerCase().replace(/[^a-z]/g, '');
    if (clean.length < 10) return 0;
    const common = ['le','la','les','de','du','des','un','une','et','en','que','qui','dans','pour','sur','avec','est','sont','il','elle','nous','vous','ils','ce','cette','the','and','is','to','of','in','it','you','that','was','for','on','are','with','as','be','at','have','this'];
    let hits = 0;
    for (const w of common) {
        const regex = new RegExp('\\b' + w + '\\b', 'gi');
        hits += (text.match(regex) || []).length;
    }
    return Math.min(100, hits * 5);
}

function onTextChange() {
    const text = document.getElementById('texte').value;
    
    document.getElementById('alertCleartext').classList.remove('show');
    document.getElementById('alertNoKeys').classList.remove('show');
    
    if (text.length < 10) {
        document.getElementById('icValue').textContent = '-';
        document.getElementById('icInterpretation').textContent = 'Entrez du texte...';
        document.getElementById('icInterpretation').className = 'ic-interpretation';
        document.getElementById('keyLengthGrid').innerHTML = '<div class="keylength-item disabled"><div class="len">-</div><div class="pct">En attente</div></div>';
        document.getElementById('statsBox').style.display = 'none';
        return;
    }
    
    document.getElementById('statsBox').style.display = 'grid';
    document.getElementById('statLength').textContent = text.length;
    document.getElementById('statLetters').textContent = text.replace(/[^a-zA-Z]/g, '').length;
    
    const rawScore = quickScore(text);
    document.getElementById('statClearScore').textContent = rawScore.toFixed(0) + '%';
    
    if (rawScore > 60) {
        document.getElementById('alertCleartext').classList.add('show');
        document.getElementById('cleartextScore').textContent = rawScore.toFixed(0);
    }
    
    // IC
    const ic = calculateIC(text);
    document.getElementById('icValue').textContent = ic.toFixed(4);
    
    const icInterp = document.getElementById('icInterpretation');
    if (rawScore > 60) {
        icInterp.className = 'ic-interpretation cleartext';
        icInterp.innerHTML = '‚úÖ Texte probablement lisible';
    } else if (ic > 0.068) {
        icInterp.className = 'ic-interpretation french';
        icInterp.innerHTML = 'üî§ IC √©lev√© ‚Üí Monoalphab√©tique';
    } else if (ic > 0.050) {
        icInterp.className = 'ic-interpretation english';
        icInterp.innerHTML = 'üîë IC moyen ‚Üí Polyalphab√©tique cl√© courte';
    } else {
        icInterp.className = 'ic-interpretation random';
        icInterp.innerHTML = 'üé≤ IC bas ‚Üí Polyalphab√©tique ou autre';
    }
    
    // Key lengths (>1%)
    const analysis = analyzeKeyLength(text);
    const valid = analysis.filter(a => a.percentage >= 1);
    
    if (valid.length === 0 && rawScore < 60) {
        document.getElementById('alertNoKeys').classList.add('show');
    }
    
    const grid = document.getElementById('keyLengthGrid');
    if (valid.length === 0) {
        grid.innerHTML = '<div class="keylength-item disabled"><div class="len">-</div><div class="pct">Aucune</div></div>';
    } else {
        const maxPct = Math.max(...valid.map(a => a.percentage));
        grid.innerHTML = valid.map((a, i) => `
            <div class="keylength-item ${i === 0 ? 'selected' : ''}" onclick="selectKeyLength(${a.length})">
                <div class="len">${a.length}</div>
                <div class="pct">${a.percentage.toFixed(1)}%</div>
                <div class="bar" style="width: ${(a.percentage / maxPct) * 100}%"></div>
            </div>
        `).join('');
    }
}

function selectKeyLength(len) {
    document.getElementById('keyLengthSelect').value = len;
    document.querySelectorAll('.keylength-item').forEach(el => {
        el.classList.toggle('selected', el.querySelector('.len').textContent == len);
    });
}

// ============================================================
// XOR UI Toggle
// ============================================================
function updateXorSection() {
    const xorActive = document.querySelector('[data-cipher="xorbase64"]').classList.contains('active');
    document.getElementById('xorSection').style.display = xorActive ? 'block' : 'none';
}

// ============================================================
// CRACKING
// ============================================================
function getActiveCiphers() {
    return Array.from(document.querySelectorAll('.cipher-btn.active')).map(b => b.dataset.cipher);
}

function toggleCipher(el) { 
    el.classList.toggle('active'); 
    updateXorSection();
}

function crackAll() {
    const text = document.getElementById('texte').value;
    if (!text.trim()) return alert('Entrez un texte');
    if (isWorking) return;
    
    const ciphers = getActiveCiphers();
    if (ciphers.length === 0) return alert('S√©lectionnez au moins un chiffrement');
    
    const lang = document.getElementById('targetLang').value;
    const maxResults = parseInt(document.getElementById('maxResults').value);
    const minScore = parseInt(document.getElementById('minScore').value);
    const keyLengthVal = document.getElementById('keyLengthSelect').value;
    
    // XOR options
    const xorKey = document.getElementById('xorKey').value.trim();
    const xorKeyLength = document.getElementById('xorKeyLength').value;
    
    let keyLengths;
    if (keyLengthVal === 'auto') {
        const analysis = analyzeKeyLength(text);
        keyLengths = analysis.filter(a => a.percentage >= 1).map(a => a.length);
        if (keyLengths.length === 0) keyLengths = [3, 4, 5];
    } else {
        keyLengths = [parseInt(keyLengthVal)];
    }
    
    setWorking(true);
    document.getElementById('results').innerHTML = '';
    
    worker.postMessage({
        action: 'crack',
        text,
        options: { ciphers, lang, maxResults, minScore, keyLengths, xorKey, xorKeyLength }
    });
}

function displayResults(results) {
    if (results.length === 0) {
        document.getElementById('results').innerHTML = '<div class="result-box">Aucun r√©sultat ‚â• ' + document.getElementById('minScore').value + '%</div>';
        return;
    }
    
    let html = '';
    for (let i = 0; i < results.length; i++) {
        const r = results[i];
        const isWinner = i === 0;
        const langBadge = `<span class="lang-badge lang-${r.lang}">${r.lang.toUpperCase()}</span>`;
        const preview = r.text.substring(0, 100) + (r.text.length > 100 ? '...' : '');
        const wordsHtml = r.words && r.words.length > 0 
            ? `<div class="result-words">üìñ ${r.words.slice(0, 8).join(' ¬∑ ')}</div>` 
            : '';
        
        html += `
            <div class="result-box ${isWinner ? 'winner' : ''}" onclick="copyText(this)" data-text="${escapeAttr(r.text)}">
                <div class="result-header">
                    <span>
                        ${isWinner ? 'üèÜ ' : '#' + (i+1) + ' '}
                        <span class="result-cipher">${r.cipher}</span>
                        ${langBadge}
                        <span class="result-key">${r.key}</span>
                    </span>
                    <span class="result-score">${r.score.toFixed(1)}%</span>
                </div>
                <div class="result-text">${escapeHtml(preview)}</div>
                ${wordsHtml}
            </div>
        `;
    }
    
    document.getElementById('results').innerHTML = html;
}

function copyText(el) {
    const text = el.dataset.text;
    navigator.clipboard.writeText(text);
    document.getElementById('workerStatus').textContent = 'üìã Copi√©!';
    setTimeout(() => { if (!isWorking) document.getElementById('workerStatus').textContent = 'Pr√™t'; }, 1500);
}

function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }
function escapeAttr(t) { return t.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
function clearResults() { document.getElementById('results').innerHTML = ''; }

// Init
initWorker();
</script>
</body>
</html>
