<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Bataille navale ‚Äî 26x26 (v6 Anti-Replay)</title>
<style>
* { box-sizing: border-box; }
body { 
  font-family: 'Segoe UI', Tahoma, sans-serif; 
  background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 100%);
  color: #e0e8f0;
  min-height: 100vh;
  margin: 0;
  padding: 20px;
}
h2 { 
  text-align: center; 
  color: #4a9eff;
  text-shadow: 0 0 20px rgba(74,158,255,0.5);
  margin-bottom: 10px;
}
.container { max-width: 1300px; margin: 0 auto; }

/* Connexion */
#connect-box {
  background: rgba(255,255,255,0.05);
  border: 1px solid #334;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  transition: all 0.5s;
}
#connect-box.hidden { display: none; }
#connect-box h3 { margin: 0 0 10px 0; color: #6ab7ff; font-size: 14px; }

/* Mode selector */
#mode-selector {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}
.mode-btn {
  flex: 1;
  padding: 12px;
  background: rgba(0,50,100,0.3);
  border: 2px solid #3a5a7a;
  border-radius: 8px;
  color: #8ac;
  cursor: pointer;
  text-align: center;
  transition: all 0.3s;
}
.mode-btn:hover { background: rgba(0,80,150,0.4); }
.mode-btn.selected {
  background: linear-gradient(180deg, #2a5a9a, #1a3a6a);
  border-color: #4a9eff;
  color: #fff;
  box-shadow: 0 0 15px rgba(74,158,255,0.3);
}
.mode-btn .icon { font-size: 24px; display: block; margin-bottom: 5px; }
.mode-btn .label { font-weight: bold; }
.mode-btn .desc { font-size: 10px; opacity: 0.7; margin-top: 3px; }

/* Password box */
#password-box {
  background: rgba(0,80,50,0.3);
  border: 1px solid #4a8;
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 15px;
}
#password-box label {
  display: block;
  font-size: 12px;
  color: #6c8;
  margin-bottom: 5px;
}
#password-box input {
  width: 100%;
  padding: 8px;
  background: #0a1020;
  border: 1px solid #4a8;
  border-radius: 4px;
  color: #4f8;
  font-family: monospace;
  font-size: 14px;
  letter-spacing: 2px;
}
#password-box .hint {
  font-size: 10px;
  color: #686;
  margin-top: 5px;
}
#password-box .crypto-info {
  font-size: 9px;
  color: #68a;
  margin-top: 8px;
  padding: 5px;
  background: rgba(0,50,100,0.3);
  border-radius: 4px;
}

textarea { 
  width: 100%; 
  height: 70px; 
  background: #0a1020;
  border: 1px solid #445;
  border-radius: 5px;
  color: #8f8;
  font-family: monospace;
  font-size: 11px;
  padding: 8px;
  resize: none;
}
button { 
  margin: 5px 5px 5px 0; 
  padding: 8px 16px; 
  background: linear-gradient(180deg, #2a5a9a, #1a3a6a);
  border: 1px solid #4a7aba;
  border-radius: 5px;
  color: #fff;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s;
}
button:hover { 
  background: linear-gradient(180deg, #3a7aca, #2a5a9a);
  box-shadow: 0 0 15px rgba(74,158,255,0.4);
}
button:disabled { opacity: 0.4; cursor: not-allowed; }

/* Status */
#status {
  text-align: center;
  font-size: 18px;
  padding: 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  margin-bottom: 15px;
  border: 1px solid #334;
}

/* Grilles */
#game-area { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
.grid-container {
  background: rgba(0,20,40,0.6);
  border: 2px solid #2a4a6a;
  border-radius: 10px;
  padding: 15px;
}
.grid-container h4 { 
  margin: 0 0 10px 0; 
  text-align: center;
  color: #8ac;
  font-size: 14px;
}
canvas { 
  border: 2px solid #3a5a7a;
  border-radius: 5px;
  background: linear-gradient(180deg, #051525 0%, #0a2035 100%);
  cursor: crosshair;
}
canvas.blink { 
  animation: blink 0.5s infinite;
  box-shadow: 0 0 25px rgba(255,200,0,0.6);
}
@keyframes blink { 
  0%, 100% { border-color: #3a5a7a; }
  50% { border-color: #fc0; } 
}

/* Panel lat√©ral */
#side-panel {
  background: rgba(0,20,40,0.6);
  border: 2px solid #2a4a6a;
  border-radius: 10px;
  padding: 15px;
  min-width: 180px;
  max-width: 200px;
}
#side-panel h4 { 
  margin: 0 0 10px 0; 
  color: #8ac; 
  text-align: center;
  border-bottom: 1px solid #3a5a7a;
  padding-bottom: 8px;
  font-size: 13px;
}
.ship-status {
  display: flex;
  align-items: center;
  margin: 6px 0;
  padding: 5px 6px;
  background: rgba(0,50,100,0.3);
  border-radius: 5px;
  font-size: 11px;
}
.ship-status.sunk {
  background: rgba(150,0,0,0.3);
  text-decoration: line-through;
  opacity: 0.5;
}
.ship-icon { display: flex; margin-right: 8px; }
.ship-cell {
  width: 10px;
  height: 10px;
  background: #4a9;
  margin: 1px;
  border-radius: 2px;
}
.ship-status.sunk .ship-cell { background: #944; }
.ship-name { flex: 1; }
.ship-ability { font-size: 10px; color: #fc0; }

/* Tirs sp√©ciaux */
#fire-mode {
  margin: 10px 0;
  padding: 10px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
}
#fire-mode h4 { margin: 0 0 8px 0; font-size: 12px; color: #8ac; }
.fire-btn {
  display: block;
  width: 100%;
  margin: 4px 0;
  padding: 6px;
  font-size: 11px;
  text-align: left;
}
.fire-btn.active {
  background: linear-gradient(180deg, #5a8a3a, #3a6a2a);
  border-color: #7aba4a;
  box-shadow: 0 0 10px rgba(100,200,50,0.4);
}
.fire-btn:disabled { opacity: 0.3; }
.fire-btn .warning {
  font-size: 9px;
  color: #f84;
  display: block;
  margin-top: 2px;
}

/* Chat */
#chat-box {
  margin-top: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
}
#chat-box h4 { margin: 0 0 8px 0; font-size: 12px; color: #8ac; }
#chat-messages {
  height: 80px;
  overflow-y: auto;
  background: #0a1020;
  border-radius: 4px;
  padding: 5px;
  font-size: 11px;
  margin-bottom: 5px;
}
.chat-msg { margin: 2px 0; }
.chat-msg.me { color: #4f8; }
.chat-msg.them { color: #f84; }
#chat-input {
  width: calc(100% - 50px);
  padding: 5px;
  background: #0a1020;
  border: 1px solid #445;
  border-radius: 4px;
  color: #fff;
  font-size: 11px;
}
#chat-send { width: 45px; padding: 5px; font-size: 10px; }

/* Info overlay */
.info-overlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,50,100,0.95);
  border: 2px solid #4af;
  border-radius: 10px;
  padding: 20px 30px;
  font-size: 18px;
  z-index: 100;
  text-align: center;
  box-shadow: 0 0 30px rgba(50,150,255,0.5);
  animation: infoPulse 0.5s;
}
.info-overlay.danger {
  background: rgba(100,30,0,0.95);
  border-color: #f84;
  box-shadow: 0 0 30px rgba(255,100,50,0.5);
}
.info-overlay.victory {
  background: rgba(0,80,50,0.95);
  border-color: #4f8;
  box-shadow: 0 0 40px rgba(50,255,100,0.6);
}
.info-overlay .password-reveal {
  margin-top: 15px;
  padding: 15px;
  background: rgba(0,0,0,0.4);
  border-radius: 8px;
  font-family: monospace;
  font-size: 28px;
  letter-spacing: 3px;
  color: #4f8;
  text-shadow: 0 0 10px rgba(100,255,150,0.8);
}
.info-overlay .session-id {
  margin-top: 10px;
  font-size: 10px;
  color: #68a;
  font-family: monospace;
}
@keyframes infoPulse {
  0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
  100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}

/* L√©gende */
.legend {
  display: flex;
  gap: 15px;
  justify-content: center;
  margin-top: 15px;
  font-size: 11px;
  flex-wrap: wrap;
}
.legend-item { display: flex; align-items: center; gap: 5px; }
.legend-box { width: 14px; height: 14px; border-radius: 3px; }

/* Session info */
#session-info {
  font-size: 10px;
  color: #68a;
  text-align: center;
  margin-top: 10px;
  font-family: monospace;
}
#session-info.active { color: #4f8; }
</style>
</head>
<body>

<div class="container">
  <h2>‚öì Bataille Navale ‚öì</h2>

  <div id="connect-box">
    <h3>üîó Connexion WebRTC</h3>
    
    <div id="mode-selector">
      <div class="mode-btn selected" data-mode="lan" onclick="selectMode('lan')">
        <span class="icon">üè†</span>
        <span class="label">LAN</span>
        <span class="desc">M√™me r√©seau local</span>
      </div>
      <div class="mode-btn" data-mode="wan" onclick="selectMode('wan')">
        <span class="icon">üåê</span>
        <span class="label">WAN</span>
        <span class="desc">Via Internet (STUN)</span>
      </div>
    </div>
    
    <div id="password-box">
      <label>üîê Password secret (8 car. max) :</label>
      <input type="text" id="secret-password" maxlength="8" placeholder="P@$$w0rd">
      <div class="hint">‚ö° Le vainqueur d√©chiffrera ton password gr√¢ce √† ta grille r√©v√©l√©e</div>
      <div class="crypto-info">
        üõ°Ô∏è <b>Anti-replay v6</b> : PWD ‚äï SHA256(grille + timestamp + nonce1 + nonce2)
      </div>
    </div>
    
    <button onclick="createOffer()">Cr√©er partie</button>
    <button onclick="applyRemote()">Appliquer code re√ßu</button>
    <p style="margin:8px 0 4px;font-size:12px;color:#888;">Code local :</p>
    <textarea id="local" readonly onclick="this.select()"></textarea>
    <p style="margin:8px 0 4px;font-size:12px;color:#888;">Code re√ßu :</p>
    <textarea id="remote" placeholder="Colle ici le code de l'autre joueur..."></textarea>
  </div>

  <div id="status">‚è≥ En attente de connexion‚Ä¶</div>
  <div id="session-info"></div>

  <div id="game-area">
    <div class="grid-container">
      <h4>üõ°Ô∏è Ma flotte</h4>
      <canvas id="myGrid" width="520" height="520"></canvas>
    </div>
    <div class="grid-container">
      <h4>üéØ Grille ennemie</h4>
      <canvas id="enemyGrid" width="520" height="520"></canvas>
    </div>
    <div id="side-panel">
      <h4>üéØ Flotte ennemie</h4>
      <div id="enemy-ships"></div>
      
      <div id="fire-mode">
        <h4>üí• Mode de tir</h4>
        <button class="fire-btn active" data-mode="normal" onclick="setFireMode('normal')">
          üîπ Tir normal
        </button>
        <button class="fire-btn" data-mode="torpedo" onclick="setFireMode('torpedo')">
          üêü Torpille (ligne)
          <span class="warning">‚ö†Ô∏è R√©v√®le ton sous-marin</span>
        </button>
        <button class="fire-btn" data-mode="bomb" onclick="setFireMode('bomb')">
          üí£ Bombe (croix)
          <span class="warning">‚ö†Ô∏è R√©v√®le ton porte-avions</span>
        </button>
        <button class="fire-btn" data-mode="radar" onclick="setFireMode('radar')">
          üì° Radar (3√ó3)
          <span class="warning">‚ö†Ô∏è R√©v√®le ton destroyer</span>
        </button>
      </div>
      
      <div id="chat-box">
        <h4>üí¨ Chat (8 car.)</h4>
        <div id="chat-messages"></div>
        <input type="text" id="chat-input" maxlength="8" placeholder="Message...">
        <button id="chat-send" onclick="sendChat()">OK</button>
      </div>
      
      <h4 style="margin-top:15px;">üõ°Ô∏è Ma flotte</h4>
      <div id="my-ships"></div>
    </div>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-box" style="background:#4a9;"></div> Navire</div>
    <div class="legend-item"><div class="legend-box" style="background:#fc0;"></div> Touch√©</div>
    <div class="legend-item"><div class="legend-box" style="background:#e22;"></div> Coul√©</div>
    <div class="legend-item"><div class="legend-box" style="background:#456;"></div> Rat√©</div>
    <div class="legend-item"><div class="legend-box" style="background:#26a;"></div> Radar</div>
    <div class="legend-item"><div class="legend-box" style="background:#a3f;"></div> R√©v√©l√©</div>
  </div>
</div>

<script>
/* ===================== CONSTANTES ===================== */
const SIZE = 26;
const CELL = 20;
const SHIPS = [
  { name:"Porte-avions", size:5, ability:"bomb" },
  { name:"Cuirass√©", size:4, ability:null },
  { name:"Croiseur", size:3, ability:null },
  { name:"Sous-marin", size:3, ability:"torpedo" },
  { name:"Destroyer", size:2, ability:"radar" }
];

const EMPTY = 0, SHIP = 1, HIT = 2, MISS = 3, SUNK = 4, ADJ = 5, RADAR = 6, REVEALED = 7;

/* ===================== √âTAT ===================== */
let myGrid = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
let enemyView = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
let ships = [];
let enemySunk = [];
let myTurn = false;
let gameStarted = false;
let fireMode = "normal";
let connectionMode = "lan";

// Chiffrement anti-replay
let myPassword = "";
let enemyEncryptedPassword = null;
let enemyShipCells = [];

// Session √©ph√©m√®re (anti-replay)
let sessionTimestamp = 0;
let myNonce = null;
let enemyNonce = null;
let sessionReady = false;

/* ===================== CANVAS ===================== */
const myC = document.getElementById("myGrid");
const enC = document.getElementById("enemyGrid");
const myCtx = myC.getContext("2d");
const enCtx = enC.getContext("2d");

/* ===================== AUDIO ===================== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playTone(freq, duration, type='sine', vol=0.3) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playSound(result) {
  if (result === "miss") {
    playTone(120, 0.3, 'sine', 0.2);
  } else if (result === "hit") {
    playTone(600, 0.1, 'square', 0.2);
    setTimeout(() => playTone(800, 0.1, 'square', 0.15), 100);
  } else if (result === "sunk") {
    playTone(400, 0.15, 'sawtooth', 0.25);
    setTimeout(() => playTone(300, 0.15, 'sawtooth', 0.2), 150);
    setTimeout(() => playTone(200, 0.4, 'sawtooth', 0.3), 300);
  } else if (result === "radar") {
    playTone(1000, 0.1, 'sine', 0.15);
    setTimeout(() => playTone(1200, 0.1, 'sine', 0.1), 150);
    setTimeout(() => playTone(1400, 0.1, 'sine', 0.08), 300);
  } else if (result === "revealed") {
    playTone(300, 0.15, 'sawtooth', 0.2);
    setTimeout(() => playTone(250, 0.2, 'sawtooth', 0.15), 150);
  } else if (result === "victory") {
    playTone(523, 0.2, 'sine', 0.3);
    setTimeout(() => playTone(659, 0.2, 'sine', 0.3), 200);
    setTimeout(() => playTone(784, 0.4, 'sine', 0.4), 400);
  }
}

/* ===================== CRYPTO ANTI-REPLAY ===================== */

// G√©n√®re un nonce al√©atoire de 8 octets
function generateNonce() {
  return Array.from(crypto.getRandomValues(new Uint8Array(8)));
}

// Convertit la grille en cha√Æne de bits (positions bateaux)
function gridToString(shipCells) {
  // Trie les cellules pour un ordre d√©terministe
  const sorted = [...shipCells].sort((a, b) => a[1] * SIZE + a[0] - (b[1] * SIZE + b[0]));
  return sorted.map(([x, y]) => `${x},${y}`).join('|');
}

// Construit le sel de session unique
function buildSessionSalt() {
  if (!myNonce || !enemyNonce) return null;
  
  // Combine timestamp + nonces (ordre d√©terministe : min nonce d'abord)
  const n1 = myNonce.join(',');
  const n2 = enemyNonce.join(',');
  const orderedNonces = n1 < n2 ? `${n1}|${n2}` : `${n2}|${n1}`;
  
  return `T=${sessionTimestamp}|${orderedNonces}`;
}

// Hash SHA-256 (retourne 32 octets)
async function sha256(message) {
  const encoder = new TextEncoder();
  const data = encoder.encode(message);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  return new Uint8Array(hashBuffer);
}

// Chiffre le password avec grille + sel de session
async function encryptPassword(password, shipCells) {
  const gridStr = gridToString(shipCells);
  const salt = buildSessionSalt();
  const combined = `${gridStr}||${salt}`;
  
  // SHA-256 ‚Üí 32 octets, on prend les 8 premiers
  const hash = await sha256(combined);
  const key = hash.slice(0, 8);
  
  const encrypted = [];
  for (let i = 0; i < 8; i++) {
    const charCode = i < password.length ? password.charCodeAt(i) : 0;
    encrypted.push(charCode ^ key[i]);
  }
  
  console.log("üîê Encrypt:", { gridStr: gridStr.substring(0, 50) + "...", salt, keyHex: Array.from(key).map(b => b.toString(16).padStart(2, '0')).join('') });
  
  return encrypted;
}

// D√©chiffre le password avec la grille ennemie reconstitu√©e
async function decryptPassword(encrypted, shipCells) {
  const gridStr = gridToString(shipCells);
  const salt = buildSessionSalt();
  const combined = `${gridStr}||${salt}`;
  
  const hash = await sha256(combined);
  const key = hash.slice(0, 8);
  
  let decrypted = "";
  for (let i = 0; i < 8; i++) {
    const charCode = encrypted[i] ^ key[i];
    if (charCode > 0 && charCode < 128) {
      decrypted += String.fromCharCode(charCode);
    }
  }
  
  console.log("üîì Decrypt:", { gridStr: gridStr.substring(0, 50) + "...", salt, keyHex: Array.from(key).map(b => b.toString(16).padStart(2, '0')).join(''), result: decrypted });
  
  return decrypted;
}

// R√©cup√®re toutes les cellules de mes bateaux
function getMyShipCells() {
  const cells = [];
  for (const s of ships) {
    for (const c of s.cells) {
      cells.push(c);
    }
  }
  return cells;
}

// Affiche les infos de session
function updateSessionInfo() {
  const el = document.getElementById("session-info");
  if (sessionReady) {
    const salt = buildSessionSalt();
    const shortSalt = salt ? salt.substring(0, 40) + "..." : "N/A";
    el.textContent = `üîí Session: ${shortSalt}`;
    el.className = "active";
  } else if (sessionTimestamp) {
    el.textContent = `‚è≥ Handshake en cours... (T=${sessionTimestamp})`;
    el.className = "";
  } else {
    el.textContent = "";
  }
}

/* ===================== DESSIN ===================== */
function draw(ctx, grid, reveal=false) {
  ctx.clearRect(0, 0, 520, 520);
  
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const px = x * CELL, py = y * CELL;
      const v = grid[y][x];
      
      let bg = '#0a1a2a';
      if (v === SHIP && reveal) bg = '#2a7a5a';
      else if (v === HIT) bg = '#cc9900';
      else if (v === SUNK) bg = '#cc2222';
      else if (v === MISS || v === ADJ) bg = '#3a4a5a';
      else if (v === RADAR) bg = '#2255aa';
      else if (v === REVEALED) bg = '#7733bb';
      
      ctx.fillStyle = bg;
      ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
      
      if (v === SHIP && reveal) {
        ctx.fillStyle = '#3a9a7a';
        ctx.fillRect(px + 2, py + 2, CELL - 6, 2);
      } else if (v === HIT) {
        ctx.fillStyle = '#ffcc00';
        ctx.fillRect(px + 2, py + 2, CELL - 6, 2);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px + 5, py + 5);
        ctx.lineTo(px + CELL - 5, py + CELL - 5);
        ctx.moveTo(px + CELL - 5, py + 5);
        ctx.lineTo(px + 5, py + CELL - 5);
        ctx.stroke();
      } else if (v === SUNK) {
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(px + 2, py + 2, CELL - 6, 2);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(px + 4, py + 4);
        ctx.lineTo(px + CELL - 4, py + CELL - 4);
        ctx.moveTo(px + CELL - 4, py + 4);
        ctx.lineTo(px + 4, py + CELL - 4);
        ctx.stroke();
      } else if (v === MISS) {
        ctx.fillStyle = '#6a7a8a';
        ctx.beginPath();
        ctx.arc(px + CELL/2, py + CELL/2, 3, 0, Math.PI * 2);
        ctx.fill();
      } else if (v === RADAR) {
        ctx.fillStyle = '#4488cc';
        ctx.beginPath();
        ctx.arc(px + CELL/2, py + CELL/2, 4, 0, Math.PI * 2);
        ctx.fill();
      } else if (v === REVEALED) {
        ctx.fillStyle = '#aa66dd';
        ctx.beginPath();
        ctx.arc(px + CELL/2, py + CELL/2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('!', px + CELL/2, py + CELL/2);
      }
      
      ctx.strokeStyle = '#2a3a4a';
      ctx.lineWidth = 1;
      ctx.strokeRect(px, py, CELL, CELL);
    }
  }
}

/* ===================== PLACEMENT FLOTTE ===================== */
function canPlace(x, y, size, dir) {
  for (let i = 0; i < size; i++) {
    const nx = x + (dir ? i : 0);
    const ny = y + (dir ? 0 : i);
    if (nx >= SIZE || ny >= SIZE) return false;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const cx = nx + dx, cy = ny + dy;
        if (cx >= 0 && cx < SIZE && cy >= 0 && cy < SIZE) {
          if (myGrid[cy][cx] !== EMPTY) return false;
        }
      }
    }
  }
  return true;
}

function placeFleet() {
  for (const s of SHIPS) {
    let placed = false;
    let attempts = 0;
    while (!placed && attempts < 1000) {
      const dir = Math.random() < 0.5;
      const x = Math.floor(Math.random() * SIZE);
      const y = Math.floor(Math.random() * SIZE);
      
      if (canPlace(x, y, s.size, dir)) {
        const cells = [];
        for (let i = 0; i < s.size; i++) {
          const nx = x + (dir ? i : 0);
          const ny = y + (dir ? 0 : i);
          myGrid[ny][nx] = SHIP;
          cells.push([nx, ny]);
        }
        ships.push({name: s.name, size: s.size, ability: s.ability, cells, hits: 0});
        placed = true;
      }
      attempts++;
    }
  }
}

function updateShipDisplay() {
  let myHtml = '';
  for (const s of ships) {
    const sunk = s.hits === s.cells.length;
    const abilityText = s.ability ? `<div class="ship-ability">${getAbilityIcon(s.ability)}</div>` : '';
    myHtml += `<div class="ship-status ${sunk ? 'sunk' : ''}">
      <div class="ship-icon">${'<div class="ship-cell"></div>'.repeat(s.size)}</div>
      <span class="ship-name">${s.name}</span>
      ${abilityText}
    </div>`;
  }
  document.getElementById("my-ships").innerHTML = myHtml;
  
  let enHtml = '';
  for (const s of SHIPS) {
    const sunk = enemySunk.includes(s.name);
    const abilityText = s.ability ? `<div class="ship-ability">${getAbilityIcon(s.ability)}</div>` : '';
    enHtml += `<div class="ship-status ${sunk ? 'sunk' : ''}">
      <div class="ship-icon">${'<div class="ship-cell"></div>'.repeat(s.size)}</div>
      <span class="ship-name">${s.name}</span>
      ${abilityText}
    </div>`;
  }
  document.getElementById("enemy-ships").innerHTML = enHtml;
  
  updateFireButtons();
}

function getAbilityIcon(ability) {
  if (ability === "torpedo") return "üêü";
  if (ability === "bomb") return "üí£";
  if (ability === "radar") return "üì°";
  return "";
}

function updateFireButtons() {
  const subAlive = ships.some(s => s.ability === "torpedo" && s.hits < s.cells.length);
  const carrierAlive = ships.some(s => s.ability === "bomb" && s.hits < s.cells.length);
  const destroyerAlive = ships.some(s => s.ability === "radar" && s.hits < s.cells.length);
  
  document.querySelector('[data-mode="torpedo"]').disabled = !subAlive;
  document.querySelector('[data-mode="bomb"]').disabled = !carrierAlive;
  document.querySelector('[data-mode="radar"]').disabled = !destroyerAlive;
  
  if ((fireMode === "torpedo" && !subAlive) ||
      (fireMode === "bomb" && !carrierAlive) ||
      (fireMode === "radar" && !destroyerAlive)) {
    setFireMode("normal");
  }
}

placeFleet();
draw(myCtx, myGrid, true);
draw(enCtx, enemyView, false);
updateShipDisplay();

/* ===================== MODE DE TIR ===================== */
function setFireMode(mode) {
  fireMode = mode;
  document.querySelectorAll('.fire-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
}

/* ===================== CASES ADJACENTES ===================== */
function markAdjacentCells(grid, cells) {
  for (const [cx, cy] of cells) {
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = cx + dx, ny = cy + dy;
        if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
          if (grid[ny][nx] === EMPTY) {
            grid[ny][nx] = ADJ;
          }
        }
      }
    }
  }
}

function markShipSunk(grid, cells) {
  for (const [cx, cy] of cells) {
    grid[cy][cx] = SUNK;
  }
  markAdjacentCells(grid, cells);
}

/* ===================== MODE CONNEXION ===================== */
function selectMode(mode) {
  connectionMode = mode;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('selected'));
  document.querySelector(`[data-mode="${mode}"]`).classList.add('selected');
  
  if (pc) {
    pc.close();
    createPeerConnection();
  }
}

/* ===================== WEBRTC ===================== */
let pc = null;
let dc = null;

function createPeerConnection() {
  const config = connectionMode === "wan" ? {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' }
    ]
  } : {};
  
  pc = new RTCPeerConnection(config);
  
  pc.onicecandidate = e => {
    if (!e.candidate) {
      document.getElementById("local").value = JSON.stringify(pc.localDescription);
    }
  };
  
  pc.ondatachannel = e => {
    dc = e.channel;
    setupDC();
  };
}

createPeerConnection();

function setupDC() {
  dc.onopen = () => {
    // √âtape 1 : Fixer le timestamp de session
    sessionTimestamp = Date.now();
    
    // √âtape 2 : G√©n√©rer et envoyer notre nonce
    myNonce = generateNonce();
    dc.send(JSON.stringify({
      type: "handshake",
      timestamp: sessionTimestamp,
      nonce: myNonce
    }));
    
    document.getElementById("status").textContent = "ü§ù Handshake crypto en cours...";
    updateSessionInfo();
  };
  
  dc.onmessage = e => handleMsg(JSON.parse(e.data));
  
  dc.onclose = () => {
    gameStarted = false;
    sessionReady = false;
    document.getElementById("status").textContent = "‚ùå Connexion ferm√©e";
    updateSessionInfo();
  };
}

// Finalise le handshake et d√©marre la partie
async function finalizeHandshake() {
  if (!myNonce || !enemyNonce) return;
  
  sessionReady = true;
  updateSessionInfo();
  
  // Chiffrer et envoyer le password
  myPassword = document.getElementById("secret-password").value.substring(0, 8);
  const encrypted = await encryptPassword(myPassword, getMyShipCells());
  dc.send(JSON.stringify({type: "encryptedPassword", data: encrypted}));
  
  gameStarted = true;
  document.getElementById("connect-box").classList.add("hidden");
  myTurn = (pc.localDescription.type === "offer");
  updateStatus();
  
  console.log("üéÆ Partie d√©marr√©e avec session anti-replay:", buildSessionSalt());
}

function createOffer() {
  dc = pc.createDataChannel("game");
  setupDC();
  pc.createOffer().then(o => pc.setLocalDescription(o));
  document.getElementById("status").textContent = "üìã Offre cr√©√©e, copie le code local...";
}

function applyRemote() {
  try {
    const data = JSON.parse(document.getElementById("remote").value);
    pc.setRemoteDescription(data).then(() => {
      if (data.type === "offer") {
        pc.createAnswer().then(a => pc.setLocalDescription(a));
        document.getElementById("status").textContent = "üìã R√©ponse cr√©√©e, copie le code local...";
      } else {
        document.getElementById("status").textContent = "üîÑ Connexion en cours...";
      }
    });
  } catch(e) {
    alert("Code invalide : " + e.message);
  }
}

/* ===================== CHAT ===================== */
function sendChat() {
  const input = document.getElementById("chat-input");
  const msg = input.value.trim().substring(0, 8);
  if (msg && dc && dc.readyState === "open") {
    dc.send(JSON.stringify({type: "chat", msg}));
    addChatMsg(msg, true);
    input.value = "";
  }
}

document.getElementById("chat-input").addEventListener("keypress", e => {
  if (e.key === "Enter") sendChat();
});

function addChatMsg(msg, isMe) {
  const div = document.getElementById("chat-messages");
  const el = document.createElement("div");
  el.className = "chat-msg " + (isMe ? "me" : "them");
  el.textContent = (isMe ? "‚Üí " : "‚Üê ") + msg;
  div.appendChild(el);
  div.scrollTop = div.scrollHeight;
}

/* ===================== EFFET MIROIR ===================== */
function getMirrorData(mode) {
  if (mode === "torpedo") {
    const sub = ships.find(s => s.ability === "torpedo");
    if (sub && sub.hits < sub.cells.length) {
      const y = sub.cells[0][1];
      return { type: "line", y: y, ship: "Sous-marin" };
    }
  } else if (mode === "bomb") {
    const carrier = ships.find(s => s.ability === "bomb");
    if (carrier && carrier.hits < carrier.cells.length) {
      const cx = Math.round(carrier.cells.reduce((a, c) => a + c[0], 0) / carrier.cells.length);
      const cy = Math.round(carrier.cells.reduce((a, c) => a + c[1], 0) / carrier.cells.length);
      return { type: "cross", x: cx, y: cy, ship: "Porte-avions" };
    }
  } else if (mode === "radar") {
    const destroyer = ships.find(s => s.ability === "radar");
    if (destroyer && destroyer.hits < destroyer.cells.length) {
      const dcx = destroyer.cells.reduce((a, c) => a + c[0], 0) / destroyer.cells.length;
      const dcy = destroyer.cells.reduce((a, c) => a + c[1], 0) / destroyer.cells.length;
      return { type: "distance", x: Math.round(dcx), y: Math.round(dcy), ship: "Destroyer" };
    }
  }
  return null;
}

function applyMirrorReveal(mirror) {
  if (!mirror) return;
  
  if (mirror.type === "line") {
    for (let x = 0; x < SIZE; x++) {
      if (enemyView[mirror.y][x] === EMPTY) {
        enemyView[mirror.y][x] = REVEALED;
      }
    }
    showInfoOverlay(`üêü TORPILLE ENNEMIE\nSous-marin ennemi sur ligne ${mirror.y + 1}`, true);
  } else if (mirror.type === "cross") {
    const positions = [
      [mirror.x, mirror.y],
      [mirror.x - 1, mirror.y], [mirror.x + 1, mirror.y],
      [mirror.x, mirror.y - 1], [mirror.x, mirror.y + 1]
    ];
    for (const [x, y] of positions) {
      if (x >= 0 && x < SIZE && y >= 0 && y < SIZE && enemyView[y][x] === EMPTY) {
        enemyView[y][x] = REVEALED;
      }
    }
    showInfoOverlay(`üí£ BOMBE ENNEMIE\nPorte-avions ennemi rep√©r√© !`, true);
  } else if (mirror.type === "distance") {
    showInfoOverlay(`üì° RADAR ENNEMI\nDestroyer ennemi √† ~(${mirror.x + 1}, ${mirror.y + 1})`, true);
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = mirror.x + dx, ny = mirror.y + dy;
        if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && enemyView[ny][nx] === EMPTY) {
          enemyView[ny][nx] = REVEALED;
        }
      }
    }
  }
  
  playSound("revealed");
  draw(enCtx, enemyView, false);
}

function showInfoOverlay(text, isDanger = false, isVictory = false) {
  const div = document.createElement("div");
  div.className = "info-overlay" + (isDanger ? " danger" : "") + (isVictory ? " victory" : "");
  div.innerHTML = text.replace(/\n/g, '<br>');
  document.body.appendChild(div);
  if (!isVictory) {
    setTimeout(() => div.remove(), 2500);
  }
}

/* ===================== JEU ===================== */
enC.addEventListener("click", e => {
  if (!gameStarted || !myTurn || !dc || dc.readyState !== "open") return;
  
  const x = Math.floor(e.offsetX / CELL);
  const y = Math.floor(e.offsetY / CELL);
  
  if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;
  
  if (fireMode !== "radar" && enemyView[y][x] !== EMPTY && enemyView[y][x] !== RADAR && enemyView[y][x] !== REVEALED) return;
  
  const myMirror = getMirrorData(fireMode);
  
  dc.send(JSON.stringify({type: "shot", x, y, mode: fireMode, mirror: myMirror}));
  myTurn = false;
  updateStatus();
});

function handleMsg(m) {
  // Handshake crypto
  if (m.type === "handshake") {
    enemyNonce = m.nonce;
    
    // Utiliser le timestamp le plus petit (d√©terministe)
    if (m.timestamp < sessionTimestamp) {
      sessionTimestamp = m.timestamp;
    }
    
    // Si on n'a pas encore envoy√© notre nonce, le faire
    if (!myNonce) {
      myNonce = generateNonce();
      dc.send(JSON.stringify({
        type: "handshake",
        timestamp: sessionTimestamp,
        nonce: myNonce
      }));
    }
    
    updateSessionInfo();
    
    // V√©rifier si on peut finaliser
    if (myNonce && enemyNonce) {
      finalizeHandshake();
    }
    return;
  }
  
  // R√©ception du password chiffr√© ennemi
  if (m.type === "encryptedPassword") {
    enemyEncryptedPassword = m.data;
    return;
  }
  
  if (m.type === "chat") {
    addChatMsg(m.msg, false);
    return;
  }
  
  if (m.type === "shot") {
    const results = [];
    const cells = getShotCells(m.x, m.y, m.mode);
    
    for (const [cx, cy] of cells) {
      if (cx < 0 || cx >= SIZE || cy < 0 || cy >= SIZE) continue;
      
      let hit = false, sunkShip = null;
      
      if (m.mode === "radar") continue;
      
      for (const s of ships) {
        for (const c of s.cells) {
          if (c[0] === cx && c[1] === cy && myGrid[cy][cx] === SHIP) {
            hit = true;
            s.hits++;
            myGrid[cy][cx] = HIT;
            if (s.hits === s.cells.length) {
              sunkShip = s;
              markShipSunk(myGrid, s.cells);
            }
          }
        }
      }
      
      if (!hit && myGrid[cy][cx] === EMPTY) {
        myGrid[cy][cx] = MISS;
      }
      
      results.push({
        x: cx, y: cy,
        result: hit ? (sunkShip ? "sunk" : "hit") : "miss",
        ship: sunkShip ? sunkShip.name : null,
        cells: sunkShip ? sunkShip.cells : null
      });
    }
    
    let radarDist = null;
    if (m.mode === "radar") {
      const myDestroyer = ships.find(s => s.ability === "radar");
      if (myDestroyer) {
        const dcx = myDestroyer.cells.reduce((a, c) => a + c[0], 0) / myDestroyer.cells.length;
        const dcy = myDestroyer.cells.reduce((a, c) => a + c[1], 0) / myDestroyer.cells.length;
        radarDist = Math.round(Math.sqrt((m.x - dcx) ** 2 + (m.y - dcy) ** 2));
      }
    }
    
    if (m.mirror) {
      applyMirrorReveal(m.mirror);
    }
    
    draw(myCtx, myGrid, true);
    updateShipDisplay();
    
    const hasHit = results.some(r => r.result === "hit" || r.result === "sunk");
    
    const returnMirror = getMirrorData(m.mode);
    
    dc.send(JSON.stringify({
      type: "result",
      mode: m.mode,
      results,
      radarDist,
      radarCenter: {x: m.x, y: m.y},
      mirror: returnMirror
    }));
    
    if (results.some(r => r.result === "sunk")) playSound("sunk");
    else if (hasHit) playSound("hit");
    else if (m.mode === "radar") playSound("radar");
    else playSound("miss");
    
    if (!hasHit || m.mode === "radar") myTurn = true;
    updateStatus();
    checkGameOver();
  }
  
  if (m.type === "result") {
    if (m.mode === "radar") {
      const cells = getShotCells(m.radarCenter.x, m.radarCenter.y, "radar");
      for (const [cx, cy] of cells) {
        if (cx >= 0 && cx < SIZE && cy >= 0 && cy < SIZE && (enemyView[cy][cx] === EMPTY || enemyView[cy][cx] === REVEALED)) {
          enemyView[cy][cx] = RADAR;
        }
      }
      playSound("radar");
      showInfoOverlay(`üì° RADAR\nDestroyer ennemi √†\n<b style="font-size:28px;color:#4f8;">${m.radarDist}</b> cases`, false);
    } else {
      for (const r of m.results) {
        if (r.result === "miss") {
          if (enemyView[r.y][r.x] === EMPTY || enemyView[r.y][r.x] === REVEALED) {
            enemyView[r.y][r.x] = MISS;
          }
        } else if (r.result === "hit") {
          enemyView[r.y][r.x] = HIT;
        } else if (r.result === "sunk") {
          enemySunk.push(r.ship);
          if (r.cells) {
            for (const c of r.cells) {
              enemyShipCells.push(c);
            }
            markShipSunk(enemyView, r.cells);
          }
        }
      }
      
      if (m.results.some(r => r.result === "sunk")) playSound("sunk");
      else if (m.results.some(r => r.result === "hit")) playSound("hit");
      else playSound("miss");
    }
    
    if (m.mirror && m.mode !== "normal") {
      let warnText = "";
      if (m.mirror.type === "line") warnText = "‚ö†Ô∏è Ton sous-marin a √©t√© rep√©r√© !";
      else if (m.mirror.type === "cross") warnText = "‚ö†Ô∏è Ton porte-avions a √©t√© rep√©r√© !";
      else if (m.mirror.type === "distance") warnText = "‚ö†Ô∏è Ton destroyer a √©t√© rep√©r√© !";
      
      if (warnText) {
        const warn = document.createElement("div");
        warn.style.cssText = "position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#a33;color:#fff;padding:10px 20px;border-radius:8px;font-weight:bold;z-index:100;animation:infoPulse 0.3s;";
        warn.textContent = warnText;
        document.body.appendChild(warn);
        setTimeout(() => warn.remove(), 2000);
      }
    }
    
    draw(enCtx, enemyView, false);
    updateShipDisplay();
    
    const hasHit = m.results && m.results.some(r => r.result === "hit" || r.result === "sunk");
    if (hasHit) myTurn = true;
    updateStatus();
    checkGameOver();
  }
}

function getShotCells(x, y, mode) {
  if (mode === "normal") {
    return [[x, y]];
  } else if (mode === "torpedo") {
    const cells = [];
    for (let i = 0; i < SIZE; i++) cells.push([i, y]);
    return cells;
  } else if (mode === "bomb") {
    return [
      [x, y],
      [x-1, y], [x+1, y],
      [x, y-1], [x, y+1]
    ];
  } else if (mode === "radar") {
    const cells = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        cells.push([x + dx, y + dy]);
      }
    }
    return cells;
  }
  return [[x, y]];
}

/* ===================== STATUS ===================== */
function updateStatus() {
  if (!gameStarted) {
    enC.classList.remove("blink");
    return;
  }
  if (myTurn) {
    enC.classList.add("blink");
    const modeText = {
      normal: "Tir normal",
      torpedo: "üêü TORPILLE (ligne)",
      bomb: "üí£ BOMBE (croix)",
      radar: "üì° RADAR (3√ó3)"
    };
    document.getElementById("status").innerHTML = `üéØ <b>√Ä toi !</b> Mode: ${modeText[fireMode]}`;
  } else {
    enC.classList.remove("blink");
    document.getElementById("status").innerHTML = "‚è≥ Attends ton tour...";
  }
}

/* ===================== FIN DE PARTIE ===================== */
async function checkGameOver() {
  if (ships.every(s => s.hits === s.cells.length)) {
    document.getElementById("status").innerHTML = "üíÄ <b>D√âFAITE !</b> Ta flotte est coul√©e.";
    gameStarted = false;
    enC.classList.remove("blink");
  }
  
  if (enemySunk.length === SHIPS.length) {
    // VICTOIRE ! D√©chiffrer le password ennemi
    let decryptedPassword = "";
    if (enemyEncryptedPassword && enemyShipCells.length > 0) {
      decryptedPassword = await decryptPassword(enemyEncryptedPassword, enemyShipCells);
    }
    
    document.getElementById("status").innerHTML = "üèÜ <b>VICTOIRE !</b> Flotte ennemie d√©truite !";
    gameStarted = false;
    enC.classList.remove("blink");
    
    playSound("victory");
    
    // Afficher le password d√©chiffr√© avec info session
    const salt = buildSessionSalt();
    const shortSalt = salt ? salt.substring(0, 30) : "N/A";
    
    if (decryptedPassword) {
      showInfoOverlay(
        `üèÜ VICTOIRE !<br>üîì Password ennemi d√©chiffr√© :<div class="password-reveal">${decryptedPassword}</div><div class="session-id">Session: ${shortSalt}...</div>`,
        false, true
      );
    } else {
      showInfoOverlay(`üèÜ VICTOIRE !<br><small>(Aucun password √† d√©chiffrer)</small>`, false, true);
    }
  }
}
</script>

</body>
</html>
